* Preamble
:PROPERTIES:
:DATE:     <2014-05-06 Tue 21:42>
:END:

The initial idea for tiny-sc was given by Mini-Audicle in ChucK.  http://audicle.cs.princeton.edu/mini/.  The Mini-Audicle includes a window for the Virtual Machine of ChucK, which displays running processes (shreds).  Through this GUI the user can at any point view which processes are running and stop any one of them.  Thus the idea arose to emulate such a functionality in SuperCollider.  This was implemented here with a new class ProcessRegistry in conjunction with some ancilliary methods.  From then on, the tiny-sc project developed without plan, as a series of spontaneous experiments with alternative approaches to common tasks in SuperColllider.

* Some objectives
:PROPERTIES:
:DATE:     <2014-05-05 Mon 11:25>
:END:

(To be rewritten...):

1. Track the state of the Server and of Synths.

2. Simplify the definition of SynthDef Functions with UGen generation shortcuts

3. Manage the loading of lists of buffers, and making these available to synths

4. Simplify the linking of audio inputs and outputs between synths through busses.

   - Automatically allocate and assign audio busses to inputs and outputs.

   - Automatically maintain correct order of nodes in the scsynth graph.

   - Restart entire synth graph on demand

5. Simplify and unify the mechanism for listening to control events broadcasts, by extending the mechanism of AbstractResponderFunc (eg. OSCFunc, MIDIFunc) to Views and Patterns.

* Tracking Server/Synth state



* UGen shortcuts

* Buffer handling

* Audio I/O linking

* Extending AbstractResponderFunc paradigm

What is the AbstractResponderFunc paradigm, anyway?

An attempt to describe:

** What is a Responder?
A Responder is an object that responds to data received from a source by executing an action.  The action is a function, and is given the data received as arguments.

A Responder furthermore defines for which messages that it receives from the data source it should act.  That is, it only acts on certain messages.  For example, if the source sends messages as arrays whose first element may for example be the symbol \start or the symbol \stop, the Responder may choose to act only when it receives the symbol \start, and to ignore any other messages which start with symbols other than \start.

Finally, a Responder can be activated or deactivated at any moment.  When deactivated, it will not respond to any messages.

** The Responder Paradigm

As an example, take the MIDIFunc Responder.  It listens for MIDI messages received from a source, and when a certain type of MIDI message is received (for example MIDI note on), it performs an action with the data of the message received.

Let's look at the broader picture.  This consists of:

- A source (The midi device sending the messages)
- The Responder that takes the messages and performs actions with the data.
- In most cases, there is also an "receiver" or "listener" object, which is the object that uses the actions of the Responder.  This could for example be a synth player object that wants to receive the MIDI messages to control its synth processes.

The general model of usage of a Responder could be therefore described with three elements:

1. A data or "event" or "message" source. This sends the data.
2. A responder.  This responds to the data received and performs actions, possibly manipulating the data to compute new values.
3. A listener or player.  This is the object affected or controlled by the actions of the responder.

** Generalizing Responders

Looking at the above "scenario" or paradigm, one can generalize the Responder model to include other data sources than MIDI, HID, or OSC.  Other data sources could be Views, Patterns or even Buffers and Busses.  Using this paradigm, one can devise a general and flexible way to connect such data sources to objects that want to use them.  For example, consider =ViewFunc= as a type of Responder for receiving data from Views.

*** Example 1: Views

To use a ViewFunc responder, the view that broadcasts the data need only use a single type of action (function):

#+BEGIN_EXAMPLE
aView.action = { | me | me.changed(\value, me.value) };
#+END_EXAMPLE

Any listener that wants to use data sent by the view can filter the message \value and attach its own action to it by creating a ViewFunc with its own function:

ViewFunc(aView, action)

The action receives the data and acts on it as required by the listener.  For example:

#+BEGIN_EXAMPLE
ViewFunc(aSlider, { | value | listener.set(\amp, value) });
#+END_EXAMPLE

or:

#+BEGIN_EXAMPLE
ViewFunc(aSlider, { | value | listener.set(\amp, listerer.spec.map(value)) });
#+END_EXAMPLE

To simplify things, creating a ViewFunc on a View sets the View's function to the default =changed(\value...)= action.  Furthermore, it sets the views =onClose= function to perform =view.objectClosed= so as to disconnect a View from all listening objects, and to notify those objects, when a View closes.

To summarize:
Using this pattern:

- Any object can connect itself to any view, and perform its own custom action when receiving data from that view.
- Views that close automatically disconnect themselves from the listeners and notify these.

The same principle can be applied to patterns that are played by a task:

*** Example 2: Patterns

A pattern - or rather a stream of values can be played in time by getting successively the next value of the stream at time intervals generated by a second stream.  Any object that wants to responds to the new value events generated by such a pattern can listen to the pattern by using a PatternFunc.  The PatternFunc can use the data as they are or can transform them with any means such as a spec, a function or even another stream.  The objects required for this are :

- PatternTask :: Play a stream of values in time.
- PatternFunc :: Respond to a stream of values from PatternTask, translating these into actions for playing a Synth or other object.

The same PatternTask function (or possibly a specialized subclass) can be used to play not just one parameter value, but a group of parameter values, in a manner similar to Pbind.  It would typically generate a new synth at each event.

Note: Two special instrument names could be used for pauses and for modulating the parameters of the same synth without restarting a new one:
- \pause
- \legato

A separate class called PatternSynth can be used to handle the playing of a pattern with PatternTask. (This is analogous to EventStreamPlayer).  This provides an interface compatible with Synth, which is needed to use a PatternTask in the synth variable of a SynthTree, and some other useful features:

- PatternSynth :: Play synths in response to events received from a PatternTask via a PatternFunc.  Enclose the synths in a separate group and route their output through a separate synth reading from a private bus, so as to provide level control, fade-in and fade-out envelope, and collective control of all currently active synths in the group.

** Filtering messages: Notification

To choose which messages from a data source to act on, the present implementation uses the Notification class.  The Notification class is similar to the SimpleController class, except that it listens to a single message - like a Responder does.   It can also be added, removed, and replaced easily with a few custom messages that are added to the Object's method protocol.  (For details see class Notification.)

An important feature of the Notification class is the addition of the objectClosed method.  This removes all dependants of the receiver as well as all Notifications that connect the receiver either as listener or as sender of messages.  Thus, objects that need to be removed of the system, such as closed windows or views, Nodes or Buffers that have been freed, can call =objectClosed= to ensure that they are no longer connected to any object in the system.  Additionally, =objectClosed= issues performs =this.changed(\objectClosed)= on the receiver object.  The means that objects that need to do something when another object closes, can register themselves to be notified of that change.

* Playing patterns
