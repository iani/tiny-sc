#+TODO: TODO STARTED REJECTED CANCELLED OBSOLETE DONE

(Copied here on: Sun, Mar  9 2014, 20:37 EET)

* Currently working on

** Review of operators
:PROPERTIES:
:DATE:     <2014-09-29 Mon 10:10>
:END:

*** source => symbol/sourcetree: set source of synthtree

Send a source to a sourcetree.  The source replaces any previous source.  The sourcetree starts playing.

*** source =>.parameter symbol/sourcetree: set source of parameter of synthtree

Send a source to a parameter of a sourcetree. The source replaces any previous source at that parameter.

*** source +> something: Modify source of synthtree

*** source %> something: Add filter to source of synthtree

*** source *> something: Obsolete?


** TODO (URGENT!) chucking into synthtree should not push environment.
:PROPERTIES:
:DATE:     <2014-06-21 Sat 19:27>
:END:

This breaks all other experimental coding with environment variables!

Workaround: one might store the last used SynthTree in Library, and access it for chucking with shortcuts using extra operators. (But this is not a first priority feature).

5 <> \freq;  // chuck into freq parameter of last operated synthtree.

** TODO make gui for controlling routines + their params with EventModel
:PROPERTIES:
:DATE:     <2014-06-21 Sat 08:29>
:END:

See BuildingEventModelGuis.scd in the present Notes folder.

(Also see: EventModelTries.scd and ControlSourceTests.scd)

This is similar to Conductor.  See for example:
http://sc3howto.blogspot.gr/2008/04/conductors-fast-gui.html

Question: How does this approach compare to Conductor?  Am I reinventing the wheel?  Need to be explicit about the differences.

** How to store/access scalar control sources?
:PROPERTIES:
:DATE:     <2014-06-20 Fri 10:20>
:END:

A synthree parameter can only have one kr control source at a time.  So that is stored in a single instance variable.  However, a synthree parameter can have multiple scalar control sources at a time.  How to access these and how to detach a chosen source from a parameter?

*** DONE [#A] option 3: store sources only globally in Library - not in param at all
CLOSED: [2014-06-21 Sat 05:36]
:PROPERTIES:
:DATE:     <2014-06-21 Sat 05:28>
:END:

This is a variant of option 2.

Already =BroadcastingResponder= and =View= work without having to be stored in the parameter.

*** REJECTED [#C] option 1: store under name in dictionary inside parameter

To be able to detach a scalar control source at any time, store scalar control sources in a dictionary under names.  It is easy to create default names, to avoid having to provide a different name explicitly each time.  Default names proposed are:

- view
- pattern
- midi
- osc

Note: =bus= and =buffer= are not scalar control sources.  Need to change older code that treats them as such.

**** Specifying scalar control source names with \synthree[name]

Consider this syntax:

: \window.slider(\myfreq) =>.freq \st[\s1];

Here =\st[\st]= is evaluated before =\st= knows that the =freq= parameter is being addressed.  To implement this, create a placeholder object =ParamSlot= that holds the name and synthree, and accesses the parameter when it is supplied by the =>.freq operator.

*** REJECTED [#C] option 2: store sources in set in param - not in dict (no names)

** STARTED Redoing kr control sources
:PROPERTIES:
:DATE:     <2014-06-18 Wed 11:32>
:END:

A kr bus (similar to BusPlug of JITLib), always registered in Library via Registry.

It will be the *only* object used to share control sources, class called =KrMap=.  It is coded and stored as follows.

*** Case 1: Storing directly in synthtree

: { ... synth code ... } =>.param \synthtree;

... accesses/creates a KrMap instance from the instance variable =krSource= inside MultiParameter stored in args under =param=, creates a kr synth from the function, and stores it in default slot =source= of that KrMap.  This new synth replaces any previous synth stored in that slot, if it exists.  If the KrMap instance is new, it is registered in Library under [SynthTree, Parmeter].

: { ... synth code ... } =>.param \synthtree[\secondSource];

... accesses/creates a KrMap instance from the instance variable =krSource= inside MultiParameter stored in args under =param=,  creates a kr synth from the function, and stores it in slot named =secondSource= of that KrMap.  This new synth replaces any previous synth stored in that slot, if it exists.

In both cases above, the KrMap instance may have been put there previously by accessing it from a KrInstance stored by Registry in the Library, or it may be created anew.  If the KrMap instance is new, it is registered in Library under [SynthTree, Parmeter].

**** TODO IMPORTANT: Free KrMaps that are replaced and not stored in Library
:PROPERTIES:
:DATE:     <2014-06-19 Thu 20:55>
:END:

KrMap *must* have a way of knowing if it is stored in Library or not.  Because, if it has been created in a param of a SynthTree without being stored in Library, then when it is replaced by a different KrMap, it should be freed, because there is no refernce to it any longer, and it becomes therefore impossible to free its bus or synths.  Therefore, store tha name of KrMap inside the KrMap instance.  If the name of a KrMap is nil, then it should be freed when replaced inside a MultIparam.  Othewise not.

*** Case 2: Accessing via name from Library

: { ... ugen code ... } => \f1.k

... start new source into \f1, in key \source of \f1.  Replace previous source in key \source of \f1 if it exists

: { ... ugen code ... } =>.source2 \f1.k

... start new source into \f1, in key \source2 of \f1.  Replace previous source in key \source2 of \f1 if it exists:

*** Case 3: Sending from library to synthtree

Send existing kr source =krsource1= to parameter =freq= of SynthTree =st1=.  The new source is stored in =krSource=, and the parameter =freq= is mapped to the bus of =krsource1=, replacing the previous KrMap.

: \krsource1.k =>.freq \st1;

Start new source in \vibrato1.k and then map to \freq parameter of \sound3:

: { source } => \vibrato1.k =>.freq \sound3;

Add new source in \vibrato1.k under key \vibrato2 and then map to \freq parameter of \sound3:

: { source } =>.vibrato2 \vibrato1.k =>.freq \sound3;

** STARTED Operator review: => for setting sources +> for modifying them
:PROPERTIES:
:DATE:     <2014-06-15 Sun 09:14>
:END:

When using an adverb, => can act as a modifier to the parameter given by the argument. Use that, leaving +> to signify modifying an existing source inside an st.  Applies [only?] to patterns.

: \source =>.param \target

Trying new scheme

** Considering \synthtree[]

- control => \synthtree[\name] :: stores control under a name in synthree so that it can be later accessed or replaced.

*** list of cases

**** => Send source to synthtree or part of synthtree
- { function } => \symbol :: play func into synthtree
- { function } =>.paramame \symbol :: play func into parameter of synthtree. The name used to store the control instance defaults to parameter's name.
- { function } =>.paramame \symbol[\sourcename] :: play func into parameter of synthtree, storing under \sourcename.
- number =>.paramname \symbol :: set parameter of synthtree to number value
- event => \symbol :: play event as pattern in synthree
- array => \symbol :: play array as event in parameters of synthtree.  Replaces previous pattern under that name. Name defaults to 'pattern'.
- array => \symbol[\patternname] :: play array as event in parameters of synthtree, naming the pattern, so that multiple patterns can be played.
- \sourcename => \symbol :: play named source into synthree, in manner depending on type of source.  Adverb and index specifications apply.  Use shortcut methods to specify type of sourcename to be accessed, as shown in the following section
**** object-from-symbol shortcut methods
:PROPERTIES:
:DATE:     <2014-06-17 Tue 16:58>
:END:
  - b :: buffer
  - p :: pattern, single, cloned from Edef
  - pm :: pattern, shared from Bdef
  - f :: function template (for kr synth)
  - k :: kr bus receiving input from one or more kr synths?
  - t :: template for ar synth (synthdef) to be played as source of synthtree.
  - o :: osc source (shared by any number of receivers via =changed=).
  - m :: midi source (shared by any number of receivers via =changed=). Following shortcuts can access and or create+register such sources:
    - noteOn(...)
    - noteOff(...)
    - cc(...)
    - afterTouch(...)
    - pitchBend(...)
  - v :: view (shared by any number of receivers via =changed=).
  - st or s :: synthtree: links synthtree as input to right argument (must be tested, alternative or replacement of =<)

**** +> Modify pattern playing as source of synthree or part of synthree

- event +> \symbol :: modify existing pattern
- array +> \symbol[\patname] :: modify existing pattern stored under \patname

*** implementation note: can be done on top of curent scheme... using adverb presence to distinguish
:PROPERTIES:
:DATE:     <2014-06-17 Tue 16:48>
:END:

*** mix (shortcut): play multiple sythtrees into one synthree, mixing their signals

: \synthree mix: [synthree array]

or:

: \synthree.mix(st1, st2, st3 ...)

Shortcut for:

({ Inp.ar } => \synthtree)
=< st1
=< st2
...



** STARTED Control Sources (+MultiControl: Single control source)
:PROPERTIES:
:DATE:     <2014-06-13 Fri 09:24>
:END:

Simplify the way in which diverse controls are added to a MultiControl instance.
Possibly make MultiControl a base Class - not an IdentityDictionary.

*** OBSOLETE two types of control sources:

**** =ControlSource= unnamed, not-shared control sources
:PROPERTIES:
:ID:       50E3FCA9-FC85-4E87-9C95-74B57A09BF51
:eval-id:  2
:END:

- added to a synth's parameter by object:

#+BEGIN_EXAMPLE
{ function } +>.paramname \synthtree;

number +>.paramname \synthtree;

buffer +>.paramname \synthtree;

`\bufname +>.paramname \synthtree;

NoteOn(...) +>.paramname \synthtree;
NoteOff(...) +>.paramname \synthtree;
Cc(...) +>.paramname \synthtree;
AfterTouch(...) +>.paramname \synthtree;
PitchBend(...) +>.paramname \synthtree;

Where the args for the above midi objects are as in MIDIFunc, with the addition of a map spec or func:

: spec, ccNum, chan, srcID, argTemplate

OSCctl +>.paramname \synthtree;

Where =OSCctl= encapsulates the arguments for creating the OSCFunc, with the addition of a map spec or func:

: spec, path, srcID, recvPort, argTemplate

Event +>.paramname \synthree;

#+END_EXAMPLE

- when a new control source is added, the previous one is freed.

- starting and stopping or freeing of the control source is independent of the starting and stopping of the controlled parameter's synthtree.   However, there are explicit messages / operators for starting, stopping or freeing or removing of a control of a parameter.

- implementations for starting, stopping, freeing and for initializing (reconnecting) when controlled synth restarts are coded by subclassing.

**** =SharedControlSource= named, registered, shared control sources

- added to a synthtree's parameter by name:

: \controlsource +>.paramname \synthtree;

- created and registered in global register, using Registry

- Connected to listeners through =Notification=, broadcast their changes through the =changed= message mechanism.


*** OBSOLETE instance var control:

may contain one of:
- MIDIfunc
- EventStream
- OSCfunc
- Bus
- A protean kind of broadcasting control source of yet undefined class (not yet implemented).

when setting control:

1. Disconnect previous control.
2.

** DONE Make => work on synth arguments
:PROPERTIES:
:DATE:     <2014-06-11 Wed 22:40>
:END:

: 500 =>.freq \st;

Is the same as:

: \st.set(\freq, 500);

Considerations:

One could use => to set params to Buffers, (getting index from buffer),

: \buffername.buf =>.buf1 => \st;

Or
: ~abuffer =>.buf1 => \st;

Or:

: \buffername.b => \st;  // ctlname defaults to \buf

Or to map to busses!

Or to play a pattern in a parameter!  Note:  One could play these as EventStreams (even Edefs or Idefs), using a set eventType, that does synth.set(param, val) as its action.  See SC Help, =Event types=:

#+BEGIN_EXAMPLE
set
   used to set parameters of some already-running node(s).
#+END_EXAMPLE

But note: The set event should be modified to set the SynthTree's param instead of the Synth directly.  This because we may want to continue playing the pattern into the SynthTree while its synth changes.

Or to play a control rate synth func into a parameter! (easy: create the synth, chuck it into a bus, and then map the param to the bus.  Possibly register the bus with NameSpace(synthtree, param), or use a BusFunc in a MultiCtl.)

** TODO stSet event type
:PROPERTIES:
:ID:       0D38B0AD-9FFC-4206-8529-A50953D37046
:eval-id:  2
:END:

#+BEGIN_EXAMPLE
stSet: #{
    ~stParam.set(~param.value)
}
#+END_EXAMPLE

** TODO Review Edef operator behavior
:PROPERTIES:
:DATE:     <2014-06-10 Tue 18:37>
:END:

Draft:

*** Part 1: Playing into SynthTree (pass 1 completed)

- \edef => \synthtree :: play new Bdef from edef into synthree.
  - Question: What if the same edef's bdef is already playing in this synthtree?  Start a new Bdef, or do nothing?
  - STATUS: Pass 1 completed.
- (event) => \synthtree :: play event as Bdef in synthree / replace if exists
  - STATUS: Pass 1 completed.
- (event) +> \synthtree :: modify previous Bdef if existing
  - TODO: If not existing, create new one.
- \edef =< (event) :: Create new edef if needed.  If edef has no children, then create a new SynthTree and play edef into it.  Else modify existing edef.
  - STATUS: Pass 1 completed.

*** Part 2: Playing Idefs without SynthTree (INCOMPLETE)

- \edef => `\idef :: play \edef into Idef named \idef.
  - STATUS: Pass 1 done.
  - QUESTION: Perhaps use different operator instead of `?
    Answer: Using the same operator is probably simpler to remember, and ` as "not a SynthTree" may be also easy to remember.  So for the moment, keep the ` syntax.
  - PROBLEM: What if a different edef is chucked into the same idef?
    Change idef's parent?  Perhaps yes.
- (event) => `\idef :: Play event as source of idef's EventStream.  Create Idef if it does not exist.  In any case, idef becomes parentless (!).
  - STATUS: TODO.
- (event) +> `\idef :: Modify (or create if not existing) idef.
  + STATUS: TODO.

[... more to come].

*** Testing:

#+BEGIN_EXAMPLE
\edef => \est; // replaces
\edef =< (degree: [0, 7].pwhite); // creates or modifies
\edef =< (dur: [0.2, 0.1].prand); // creates or modifies
(dur: 0.1) => \est; // also replaces
(degree: [0, 7].pwhite) +> \est;  // creates or modifies
#+END_EXAMPLE

#+BEGIN_EXAMPLE
\edef => `\idef;
#+END_EXAMPLE



** New approach to try: Implement the current operrators for synths and patterns using Ndef, Pdef and related JITlib classes, to locate overlaps and possible differences.
:PROPERTIES:
:DATE:     <2014-04-28 Mon 22:12>
:END:


** Both single-synth and synth-stream should play with PatternInstrument
:PROPERTIES:
:DATE:     <2014-04-18 Fri 16:24>
:END:

 - SynthTree.legato (SynthTree.l) :: play with Pmono-like event.play function
 - SynthTree.nonLegato (SynthTree.nl) :: play with usual event.play function

To consider: Should legato also play in bus like non-legato?  That would provide consistent fadein-fadeout and simplify coding, but waste bus...

** fix ref chuck to synthtree symbol
:PROPERTIES:
:DATE:     <2014-04-18 Fri 16:39>
:END:

If the instrument is a single synthdef, one may chuck it directly in the tree:
#+BEGIN_EXAMPLE
`\sine => \test2;
#+END_EXAMPLE

** play data streams
:PROPERTIES:
:DATE:     <2014-04-07 Mon 11:44>
:END:

- as full events, single synth per data vector

- as streams of st.set(param, nextValue)

- as envelope-like shapes playing in synths and outputting in control or audio busses

Try these with arrays loaded from data analysed through SCMIR.

* Immediate TODOs

** TODO Fix Event:add2SynthTree - when template is not BdefInstrument
:PROPERTIES:
:DATE:     <2014-06-12 Thu 08:34>
:END:

		// TODO: if template is not BdefInstrument, make one!

** Revise restart-after-cmd-. scheme
:PROPERTIES:
:DATE:     <2014-06-07 Sat 17:04>
:END:

Instead of using a flag (i.e. SynthTree notStopped var):  On Command-period, add any running SynthTrees or Idefs or Bdefs to a set of objects, and use this set to restart any objects that were stopped by Command-period when running SynthTree.initTree.  Details:

The function triggered in Emacs by C-c C-x C-/ (sclang-init-synth-tree), should run the folliwing (in this order):

- init SynthTree : restart playing all SynthTree instances in set runningSynthTrees
- init Edef: restart playing all Idef, Bdef or Cdef instances in set runningEdefs

This will not cause any double-restarts, as long as Idef etc. check if they are already running before they start playing.

** Implement %!> to *remove* a filter from BdefInstrument in SynthTree
:PROPERTIES:
:DATE:     <2014-05-31 Sat 16:46>
:END:

** debug SythTree initTree
:PROPERTIES:
:DATE:     <2014-05-09 Fri 18:18>
:END:

When monitoring with
: Server.default.plotTree;

The following will create an extra, third, synth when restarting the tree with initTree:

#+BEGIN_EXAMPLE
{ LPF.ar(\in.in, \freq.kr(4000)) } => \fx;
{ WhiteNoise.ar(0.1) } => \test;
\fx =< \test;
#+END_EXAMPLE
** Add jchuck method to Ndef
:PROPERTIES:
:DATE:     <2014-05-01 Thu 12:05>
:END:

** PatternTask: Retain because more lightweight? Rename to PatternTask to avoid conflict with Conductor Quark.
:PROPERTIES:
:DATE:     <2014-04-25 Fri 19:29>
:END:

PatterPlayer is still used to play single parameters of a synth in a synthree, but it could be replaced by a Bdef/BdefInstrument which also sends values, and allows greater flexibility.

But note: Bdef/BdefInstrument are much heavier.

Maybe rename PatternTask to PatternTask!!!


** Implement @> for mapping control busses to synthtree params

** Use Linen for adsrOut

adsrOut => linOut;

Adsr is superfluous.
y
** SynthTree:

*** fix ==> n_free Node not found when =< to fx

Note: this is a glitch only.  ==> works fine, but Server sends notification warning n_free Node not found.
*** operators for: insert synth between, replace input

=^ replace previous input by this one (for example to switch input between audio in and a buffer playback, or between different buffer playback synths etc.

=^< insert synth specified by right operand between the left operand's synth and the synth of the tree specified by the symbol adverb.

*** Further:

- Test added cycle check to method addInputSynth
- =<> should set the amp of the SynthTree to 1.
- Implement fade-in by setting Adsr's attackTime value at synth creation time.
- Set operator: *>
  - =440 *>.freq \mySynth;= // set freq of mySynth to 440.
  - The *> operator may work also with busses, synths, patterns, MIDIFuncs, OSCFuncs, Views, or pubs.  However see criticism and alternative formulation in next section.
    - Bus: map to the bus
    - Synth: create bus and map to it (?) (such buses should be registered in server-global dict like SynthTrees?)
    - Patterns, etc.: make pattern or other object set the named parameter whenever it produces a new value.
    - Use messages =map=, =unmap=, =bimap= to create mappers for updating objects.  The mappers are stored in the args var of the SynthTree, so that different SynthTrees depending on the same updating object (pub) may use different mappers/specs.
**** Alternative formulation thoughts for the set operator above:

The above will only work well for setting params maybe we don't want it at all.  mySynth.set will do?  We only save the parens, I think.  S

Need to specify 3 things:

1. parameter operated on
2. operation
3. position in binop tree where the operation will take place

Also need to accommodate both busses and buffers, with name access.

\mySynth @ param <operation>.<position> <right operand/new element>

{ } => \mySynth @ param ...

Finally, better use message style, because clearer, and also chainable:
#+BEGIN_EXAMPLE
\mySynth
   .set(param, val)
   .out(param = \out, chans = 1) // creates bus ref
   .in(param = \in, chans = 1) // creates bus ref
.view(param, name, view ...) // name etc. optional. creates knob per default
// NOT:   .view(param, nameOrView = param, storeName = \view)
   .osc(param, specs = param, storeName = \osc)
   .buf(name, param, chans) // creates buf ref
   .midi(param, specs, storeName = \midi)
   .map(name, param, chans) // creates bus ref
   // following compose patterns / streams. for later? ... ?
   .add(param, element, storeName, path);
   .sub(param, element, storeName, path);
   .mul(param, element, storeName, path);
   .div(param, element, storeName, path);
   .mod(param, element, storeName, path);
   .pow(param, element, storeName, path);
   .sel(param, element, storeName, path);
   .rej(param, element, storeName, path);
   .fun(param, element, storeName, path);
   .choose(param, element, path);
   .wchoose(param, element, path);
#+END_EXAMPLE

**** StreamPattern methods / operators?
  - Pattern.play(durationPattern);
  - SequenceableCollection.play(durationPattern);

** Global Streams, StreamPatterns, Patterns, PatternTasks

Patterns, Streams, StreamPatterns and PatternTasks should be stored globally each in its own dict, and added to any number of SynthTrees.  One SynthTree might want to compose the stream source used by another SynthTree with a second stream source!

They could be stored in / accessed from the global Library.

How many categories should exist?

- Patterns :: Used to spawn streams that go directly in a MultiControl stream, privately
- Streams :: Used to store streams for global access.  Cannot respawn. Note: sharing streams as sources of values in different SynthTrees problematic (cannot call next twice - who calls first? See note below: "Important:", and next section, StreamFunc for solution of this problem).
- StreamPatterns :: Like streams, but can respawn their stream when ended.  Multiple access problem of Streams also apply here.
- PatternTasks :: Play patterns in time.  Can be distributed to multiple patterns via Notification.  Play independently of Synth start, therefore no synchronization problem.

Important:  Calling "next" on demand at synth start: Cannot ask the same stream to share with multiple events.  How to synchronize/distribute?  Common pattern player for many synth-trees?  The solution is to broadcast a stream's values with 'changed' method calls, and catch them in similar manner as a ViewFunc does (i.e. like an Responder).  Call this StreamFunc.  One can define FilterStreamFunc as a subclass of StreamFunc, to process the incoming values of with either a function or a FilterPattern, also creating BinOp trees for composing different operations on the incoming value.

** StreamFunc

see above.  (more to come)

*** PatternTasks vs SynthPlayers
PatternTasks play a single stream

SynthPlayers play a SynthTree in Pbind-like manner.  They enclose the created synth events in a single group private to the SynthTree, divert the synths to a private bus, which is then processed by a synth that provides amplitude and fadein/out control.

** Map synths to params via busses
:PROPERTIES:
:DATE:     <2014-03-23 Sun 21:48>
:END:

Map synths playing envelopes, any function, lines to input controls of other synths.  See SynthTree:map, SynthTree:fade.

** Improve keyboard commands for setting fadeTime

* More TODOs

** TODO windows for all objects

Any object should be able to register a window in Registry.

The window may have a default layout that allows to add or remove widgets
horizontally or vertically.

See draft of this Classes/Gui/GenericWindow.scd

** TODO \symbol.play

- If synthtree of same name not found: search in synthtemplates, if found, create ST with same name and play.  If not found, search in buffers and play buffer in ST with simple playbuf template.  If not found, search in patterntemplates, and

** Review / remove use of changed(\value) in PatternTask
Could a function be called directly instead, to save CPU cycles?

** EventList class

(Earlier version done in Lilt2 lib: Chain).

Instead of holding the lists (streams) of value events and durations separately, each event holds its own duration together with the data in one object.  This is good for editing event chains by cutting-pasting, inserting events or event lists to change lists or to create other lists.  May be good also for displaying event lists as a graphic score.

** Possible shortcuts for params
Draft of how this looks in code.  Different things that one could do with a synth parameter by addressing it (as MultiControl instance) through the environment:
#+BEGIN_SRC
0.03 => ~amp;
660 => ~freq;
~freq.slider;
~freq.knob;
~freq.numbox;
~freq.numSlider;
~freq.knobSlider;
~freq.oscFunc(...)
~freq.midiFunc(...);
~freq.pattern(...);  // or: ~freq.pp(...);
<a pattern player> => ~freq;

\anotherSynth.push; // switch to another SynthTree for working ...
#+END_SRC

IMPORTANT: Maybe use another operator for chucking stuff to a SynthTree *without* making it current.  Unclear yet how this all works together when for example chaining several fx synths.

*** Analysis: possible operations on parameters.
:PROPERTIES:
:DATE:     <2014-03-29 Sat 16:43>
:END:

~st: current SynthTree: => operates as usual, chucking into SynthTree.
~fx: current effect.  Can be used with =< to add new input.

All other environment parameters will return a multiparameter instance controlling one of the synthree's parameters.

There are following possibilities of chucking something to a synthree parameter:

- number :: set the synthree parameter to that number
- bus :: map the parameter to that bus
- pattern or stream :: play the pattern or stream into that parameter
- array :: convert array to pseq with inf repeats and play??????
- function :: play it into bus and map the parameter to that bus
- view :: set view to contol parameter
- OSCFunc: set func to control parameter
- MIDIFunc: set func to control parameter
- Buffer :: set bufnum to the parameter for playing the buffer
- Event :: set all params and restart.

**** TODO Constructing pattern players
Shortcut method for turning Function, pattern, array, or stream into a patternplayer for playing into the parameter: =pp=!

Alternative operator for constructing a pattern player (instead of =pp= method): Chuck:

: <values: pattern/func/array> => <durations: pattern/func/array/number>

So one can go:

: <values pat> => <durations pat> => ~freq

To construct a pattern player and play it in parameter =freq=.

One could also use this with an event, in which case there are 2 possibilities:

1. Play all associations in the event as parameter-value pairs, with the values forming streams, pbind-like, playing new synths at each new evaluation of the pattern's values.
: <event> => <durations pat> => <SynthTree>

2. Do not play new synths at each evaluation, but just set the parameters of the synth.

: <event> => <durations pat> =*> <SynthTree>

Additionally, for case 1, one may use a special instrument name such as \slur or \portamento, or '*' or '-', to skip a new synth and set the parameters of the current synth, behaving as in case 2.



**** Chucking into busses

- =<function> => bus= :: play the function to that bus
- =<envelope> => bus= :: play the envelope to that bus
- =<UGen> => bus= :: convert ugen to synth and play in that bus.  Good for playing Line.kr.  But this could be done with something like: ~amp.fadeTo(...);


*** (Older:) PatternFunc notes

#+BEGIN_EXAMPLE
<pfunc template> %> 'pfunc_name' *>.param_name SynthTree_name;

<pfunct template %> 'pfunc_name'; // creates PaternFunc and binds it to name

Alternative:

'pfunc_name'.patternFunc(<template>);
'pfunc_name'.pf(<template>); // shorter form

// also:

<pfunc template or name> *>.param_name syntree_name;
#+END_EXAMPLE

The operator *> could be a multi-purpose operator for binding any type of func (osc-, view-, midi-, pattern-funcs) to a parameter.  It could also alternatively be coded with the messages already started:

#+BEGIN_EXAMPLE
<SynthTree or name of SynthTree>
    .osc(param, <template or name>)
    .midi(param, <template or name>)
    .view(param, <template or name>)
    .pattern(param, <template or name>)
#+END_EXAMPLE

Further notes (originally written in PatternFunc.sc draft):

Binding a MultiControl to a PatternFunc:

- Store the patternfunc under its name in the multicontrol dict. (maybe construct name from name of param ++ name of pattern func to avoid conflicts?.  Must rethink idea of multicontrol as dict, and the problem of naming.  Perhaps there exist alternative names for managing access to different controllers of a multicontrol, that do not involve names?)

- Attach self to patternFunc via a notification action that goes something like:

this.addNotifier(patternFunc, \value, { | value |
	this.set(value);
});

Different actions could be added instead of { | value | this.set(value) }.
These could process (modify) / select / reject the values to be sent to the parameter, and could be composeable with binaryOps.  So one goes:

multiparam.pattern(<template or name> <operator> <filter>);
alternatively with messages:
multiparam.pattern(<template or name>.add|mul|map|unmap|select|reject(<filter>));

**** Playing SynthTree events with PatternTask/PatternFunc
Important: Alternatively, a PatternFunc may store as currentValue an event with many parameters, and SynthTrees receiving notifications from it could play that event each in its own way.

One could thus bind a whole SynthTree to a PatternFunc with the same operator:

<patrernfunc or name> *> <SynthTree or name>

When no parameter is given as adverb to the *> operator,
then the patternfunc is bound to play the whole SynthTree.

Alternatively:

<SynthTree or name>.patternPlay(<patternfunc or name>);
shorter form:
<SynthTree or name>.pp(<patternfunc or name>);

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Possible class group for playing patterns in SynthTrees, in Pbind-like manner:

- PatternTask: generates and broadcasts event values for any listener
- PatternFunc: Listens to and filters event values for a SynthTree.
	Is stored in the template var of SynthTree
	holds: The PatternTask ...
- PatternSynth: Encapsulates synths generated by patternfunc. Holds:
	- the synths
	- possibly a group and bus to fade/adjust gain of the whole output signal
	- the PatternFunc

See also: BasicIdeas.org, Extending AbstractResponderFunc paradigm -> Generalizing Responders -> Example 2: Playing Patterns.

*** SynthTreePlayer draft notes
- Should work as a template and as a synth (same instance?) in SynthTree.
- Should keep its synths in own variable, allowing for playing of multiple synths at the same time.

See also PatternTask ...


* Done

** Before [2014-03-12 Wed]
- Adsr, Sine, Perc :: Env shortcuts
- out, adsrOut, Inp :: =Out.ar=/=kr= + =adsr=, =In= shortcuts.
- Notification :: Filter "changed" notifications, add and remove notifiers.bb
- ProcessRegistry :: Keep track of running Nodes, Routines, Patterns.
- ProcessRegistryGui :: Display list of running processes, =delete= key stops selected process.
- sclang-snippets :: Shortcuts to navigate, select and run code blocks separated by =//:=.
- org-sc :: Evaluate SC code in org-mode sections and babel blocks.
  - Eval code in sections, replace/stop processes belonging to a section
  - Wrap code in Routine to permit using =wait=, and play loops.
  - Load all sections whose AUTOLOAD property is non-nil.
  - Store processes under a key representing the snippet or org-mode section from which they were started.  Thus make it possible to stop or replace the processes that belong to the current snippet or org-mode section.  For sections: Use the org-id ID as id and the name of the section for display.  For snippets: Generate name if not present in =//:= header, add number if not unique.
  - Load org-mode sections marked with AUTOLOAD property.
- Replaced old README with another one, that is less technical and more hand on.  The README consists of examples, where each example is brief and can be executed immediately with audible results to show what the library does.  For each example there should be a brief description, accompanied by pointers to the related parts of the library, where more information can be found.
- SynthTree:
  - Store all root-level SynthTrees as inputs of a \root SynthTree, for each server.  Use the =root= SynthTree to iniTree the entire tree of a server.
  - Tested connecting synths.  But changing sources of connected synths is still broken.
  - Added methods =synth=, =isPlaying=, =inputs=, =output=, =args= to Symbol.
- Test linking synths: What happens when chucking a new synth to the reader?  To the writer?  Subtests are:
  - Debug  node not found when linking more than 1 synth or at initTree.
  - Test initTree when the tree contains linked synths
** SynthTree.initTree: Do not check for playing synths
:PROPERTIES:
:DATE:     <2014-03-12 Wed 07:28>
:END:

** ViewFunc->UniqueViewFunc

Test new version UniqueViewFunc and substitute UniqueViewFunc in MultiController: view instead of ViewFunc.


** Debug MultiControl:view

Following only controls freq.  View does not control amp.

#+BEGIN_EXAMPLE
\asdf.view(\freq);
\asdf.view(\amp);

{ LFTri.ar(\freq.kr(400)) } => \asdf;
\asdf.set(\amp, 0.02);
#+END_EXAMPLE
** symbol.buf(...)

** BufferFunc

How to get buffers:

- BufferFunc(listener, buffername, server) :: make buffer named buffername available to object listener for use as synth parameter.  The parameter is the listener.   Lookup buffer at the global Library, under path [buffers, server, buffername], ask for path and load if needed.

Algorithm draft:


- Lookup buffer in library under [\buffers, server, name].

- if not found,
  - notify [return?] index of default empty buffer (preallocated).
  - open dialog box for selecting file to load
  - read buffer and immediately also:
  - register it in the library so that others can find it
  - set its numframes to -1 indicating that it is being loaded still, therefore do not reload
  - register info action of buffer read to notify self when done
  - upon receipt of info from server, notify index of new buffer, so that synths may set it.
  - register buffer in library.
- if found
  - if info of buffer has numframes > 0 (i.e. it is loaded), then return/notify index of buffer.
  - else if info is -1 then
    - register self for notification when buffer has been loaded
    - use empty buffer in the meanwhile

Upon server real boot:
- allocate default empty buffer with 256 frames mono, for use while buffers are being loaded.
- for all buffers registered in library for that server:
  - read the buffer and immediately also:
  - set its numframes to -1 indicating that it is being read.
  - get info and notify all dependants when the buffer is loaded, so that it may be used.

[possibly register all buffers in a sort of queue and notify when the queue is empty, and do SynthTree:initTree after that!!!]

** Debug SynthTree:trig:

Restarting this with ==> leaves the old synth hanging
Solution implemented: Use =|> instead of ==>

#+BEGIN_EXAMPLE
{
	var synth;
	synth = { SinOsc.ar(\freq.kr(400)) } =|> \test;
	10 do: {
		synth.trig(\freq, 400 rrand: 1200);
		0.25.wait;
	}

}.fork;
#+END_EXAMPLE

** SynthTree mixer: pnel of SynthTrees with amp faders.
:PROPERTIES:
:DATE:     <2014-03-20 Thu 11:34>
:END:

** Add key commands to SynthTree faders
:PROPERTIES:
:DATE:     <2014-03-23 Sun 21:48>
:END:

- , :: Stop running processes
- . :: Stop running processes and clear SynthTree (set all to stopped)
- i or / :: init tree = restart processes
- space :: toggle selected SynthTree: start/stop

** stop+clear tree command
Add kbd command to free the entire SynthTree and set all nodes isStopped to true.  This is good instead of Command-. to make sure that no unwanted SynthTree nodes will be restarted.  Proposed key binding: =C-c C-x C-=.

** Palettes of components for dragging onto fader gui

: Palettes.show;

Keyboard command on Emacs?

Possibly: H-c H-p ?

*** org-files with lists of SynthDefs, Functions etc.

To be stored in dicts with symbols, from which guis are created to use these with drag-and-drop onto the SynthTree fader gui or onto the Knobs gui.

** Templates

Predefined SynthDefs or Synth Functions and PatternTasks, stored under names, for use in SynthTree, selectable from SC GUI with drag-and-drop or Emacs-ido-completion.

Maybe Templates should be taggable!

So a Template class should be defined, to hold the tags along with the template.

See =Templates/AboutTemplates.org=.

Testing synthdefs chucked into SynthTrees:

#+BEGIN_EXAMPLE
d = SynthDef("asdf", { WhiteNoise.ar.adsrOut }).add;
d => \test;
#+END_EXAMPLE


** push params in currentEnvir



** fix drag start from fader DragBoth.  SynthTree:asString -> Function does not understand "name"!

** creating a new SynthTree which contains an input should make that SynthTree the current selection, so that typing control-return on a SynthTemplate selection sends it to the latest created SynthTree with input.

** Group of global keyboard commands based on H-c and H-c H-x.
Also improve the keyboard command documentation, showing the rationale for the commands:

- Basic combination 1: C-M key
- Basic combination 2: H-c key or H-c H-key
- Basic combiantion 3: H-c H-x key or H-c H-x H-key

** Push synth+parameters onto currentEnvironment
:PROPERTIES:
:DATE:     <2014-03-31 Mon 12:06>
:END:

- Chucking something into a SynthTree always makes this the selected SynthTree - on which further actions from gui or code apply.
- The selected SynthTree makes its parameter (SynthArgs) environment be the current environment, so that one can chuck stuff to the parameters through the environment!
** Make patterns restart on SynthTree.init and continue on synth chuck
(Sun, Mar 30 2014, 19:55 EEST)

#+BEGIN_EXAMPLE
{ SinOsc.ar(\freq.kr(400)) } => \sound;
// Play a pattern into ~freq:
{ 50.rrand(80).midicps }.pp(0.1) => ~freq;
// Pattern should keep playing:
{ LFPulse.ar(\freq.kr(400)) } => \sound;
// Pattern restarts when the synth starts, even after thisProcess.stop;
thisProcess.stop; // stop routines and synths
// Pattern should also restart now:
SynthTree.init;
#+END_EXAMPLE



** SynthTree: review root scheme to use envir


Insert 2 envir variables, separate for each server parent envir:
~root = the root of the server tree
~dur = the default duration for playing patterns.  Can be a stream, or even responder ... (!)

** Faders: Free, Indicate released status of synths

When fadeout is long, one may think that it is not working.  Change color of fader to indicate that fadeout has started.

** Fix mixup when restart/free during fadeout
:PROPERTIES:
:DATE:     <2014-03-31 Mon 12:24>
:END:

** Add fade-in and fade-out toggles for both selected node and entire SynthTree, with times from 0 to 9 seconds, bound to the corresponding keys from 0 to 9.

** SynthPattern draft 1 done
:PROPERTIES:
:DATE:     <2014-04-02 Wed 11:14>
:END:
(Note to self: Forget about nesting here.  For that you need EventList.)

The valueStream may produce as value an array of 3 elements:

  1. Name of synthdef to play, or nil for silence.
  2. Args array for the synth, eg: [\freq, 440, \amp, 0.1 ... etc]. The SynthTree adds the target group, addAction, and output/input parameters to create the synth.
  3. Duration after which the SynthTree should release the synth.  The SynthTree schedules a function roughly like this:

: SystemClock.sched(dur, { synth.release })

or:

: aTempoClock.sched(dur, { synth.release })

Dur may be different from the delta time for the next event of the pattern, depending on legato.

Following this through the three stages patern -> stream -> next value:

Pattern should contain:
- instrumentpattern
- parampattern
- legatopattern

These three are converted to streams and put into a SynthStream, which creates SynthEvents to play.  So we have following classes:

1. SynthPattern - contains the pattern producing the stream
2. SynthStream - contains the stream producing the event
3. SynthEvent - contains the parameters for creating the Synth

We can make these work with PatternTask.

** Fix H-M-p and H-p going backwards for org-mode

*** ! Mix (SinOsc.ar(LFNoise0.kr (15).range (70, 90).midicps * [1, 3, 5], 0, 0.2 / (1..3)) )
*** 1, 3, 5, 7
Mix (SinOsc.ar(LFNoise0.kr (11).range (50, 70).midicps * [1, 3, 5, 7], 0, 0.2 / (1..4)) )
*** Lower 1, 3, 5, 7
Mix (SinOsc.ar(LFNoise0.kr (12).range (30, 50).midicps * [1, 3, 5, 7], 0, 0.2 / (1..4)) )

** Extend PatternTask to play SynthTrees
:PROPERTIES:
:DATE:     <2014-04-02 Wed 11:16>
:END:

- Remove instrument from SynthPattern / SynthStream / SynthEvent. The instrument should be provided by the PatternFunc that plays the SynthEvent.

- fadeTime should not be given as adverb of =>.  Instead use adverb of => to specify numChan.

- add numChan as parent environment variable for SynthTree


** Check H-C-n/p

They do not immediately evaluate the chosen snippet, but work like H-p/n

Test here:

*** ! { WhiteNoise.ar } => \test

*** ! { GrayNoise.ar } => \test


** Playing patterns in SynthTree

Steps:

1. Try getting values from stream in MultiControl
2. Try timing the triggering of new synths in SynthTree with a routine
3. Try PatternFunc for control of single parameters
4. Define class SynthTreePlayer that acts similarly to Pbind, but plays a SynthTree.



** DONE Fix sending pattern synthrees to different inputs
CLOSED: [2014-04-06 Sun 21:07]

When sending a SynthTree sending a pattern to one lpf synthree, and then switching to another, hpf, SynthTree, the sound stops.  Why?

Done: PatternSynth should move only its Group, not itself as synth.

** DONE SynthTree.initTree loses Patterns in FX
CLOSED: [2014-04-07 Mon 11:03]

A pattern that outputs in an effect is not put back into that effect on SynthTree.initTree after stopping all synths.

Fixed: Supplied output bus to PatternSynth in method PatternInstrument:asSynth.

** DONE Synth timing / chaining?
CLOSED: [2014-04-07 Mon 11:06]

Implemented as a variant of this draft:

Play a synth for a given duration:

{ } => number => symbol (synthDef)

or

{ } dur: number => symbol (synthdef)

Number: receiveChuck ->

- Make routine for starting / stopping
- add SynthTree as notifier to stop if SynthTree is released/faded out/freed.

** Fix chaining with symbols, refs in patterns

Check these, and their further combinations:
#+BEGIN_EXAMPLE

[freq: { 40 rrand: 250 }.pfunc, amp: 0.2] =>.i \lpfpulse => 0.5 => \test;

[freq: { 40 rrand: 250 }.pfunc, amp: 0.2] => 0.5 =>.i \lpfpulse => \test;

\sine => \test;

`\sine => \test;

#+END_EXAMPLE

** Review binary operators

*** [Implementing:] Alternative 2: with *>

Overview / list of operators in alternative 2:

1. => chuck things to SynthTrees, create or modify PatternTasks, PatternInstruments.
2. -> associate patterns to parameters.
3. *> chuck something to a parameter of a SynthTree.
4. =< send output of a synth to the input of another synth.
5. @> map parameter of SynthTree to bus

Details:

**** value -> parameter chucking to single parameters/aspects of named SynthTree

[100, 200].pseq -> \freq => \SynthTree1

[100, 200].pseq -> \dur => \SynthTree1

**** *> chucking to single parameters/aspects of current SynthTree
*> is for chucking to single parameters or special aspects duration, legato, instrument of the current SynthTree.

Examples:

500 *> \freq;
[500, 600].pseq *> \freq;
[0.1, 0.2].pseq *> `\freq;
0.5 *> \leg;
0.1 *> \dur;
\sine *> \instr;

- anything *> symbol :: chuck to parameter of current synth.  Special parameters:
  - duration :: duration of PatternInstrument
  - dur :: synonym of dur
  - legato :: legato (not a parameter of the PatternTask)
  - leg :: synonym of legato
  - instrument :: Instrument (of PatternInstrument)
  - instr :: synonym of Instrument

- anything *> `paramname :: chuck to duration of PatternTask of parameter `paramname.

**** anything => [not symbol, not ref]: make PatternTask
- anything => [not symbol, not ref] :: make/set duration of PatternTask

Examples:


**** anything => ref : make / set instrument of PatternInstrument
- anything => ref :: make / set instrument of PatternInstrument
**** anything => Symbol: Chuck to Symbol as SyntThree
**** anything => SynthTree:  Chuck to SynthThree

*** [Rejected:] Alternative 1 (without *>)

- pattern => symbol :: play pattern in parameter named by symbol, in current SynthTree ~st.
- pattern => number :: PatternTask(pattern, number).  Number is duration
- pattern => pattern2 :: PatternTask(pattern, pattern).  Pattern2 is duration
- pattern => `symbol / `pattern :: PatternInstrument(PatternTask(pattern), symbol/pattern).  symbol/pattern is instrument
- THIS MAY NOT BE NEEDED: pattern =>.i (|>) pattern2 or => `pattern :: PatternInstrument(PatternTask(pattern), pattern2).  Pattern2 is instrument
- pattern =>.d (*>) symbol / SynthTree ::  (Synonym:) Pattern is duration pattern for SynthTree's PatternInstrument
- pattern =>.l (**>) symbol SynthTree ::  Pattern is legato pattern for SynthTree's PatternInstrument
- pattern =>.i (|>) symbol / SynthTree ::  Pattern is instrument pattern for SynthTree's PatternInstrument
- pattern => SynthTree ::  Pattern is duration pattern for SynthTree's PatternInstrument
- pattern => environment var ::

- association => number :: ...
- association :: pattern :: ...
- association :: symbol :: ...
- association :: `symbol

- number => environment var :: ...
- number => symbol :: ...
- ???? number => pattern :: ?????
- number => SynthTree :: ...
*** Implementing alternative 2
:PROPERTIES:
:DATE:     <2014-04-11 Fri 15:31>
:END:
**** Implementing =>



**** Implementing *>

***** object *> symbol:

~st.chuckToParameter(symbol, object);

***** object *> `symbolRef

~st.chuckToParameterDur(symbol, object)

**** Implementing ->



**** Implementing =<



** PatternInstrument plays event, custom action
:PROPERTIES:
:DATE:     <2014-04-14 Mon 21:59>
:END:

** Mdef: Named PatternTask Model
:PROPERTIES:
:DATE:     <2014-04-16 Wed 04:58>
:END:

To consider:
Mdef subclass of PatternTask?

Maybe try first with Ndef as independent class, containing a PatternTask or subclass as instance var player.

This could be a practical coding pattern, and is compatible with the details of the following sections:

: \pattern1 => [instrument: \bass] => \synthtree1;

Alternative to:

: Mdef(\pattern1, [instrument: \bass]) => \synthtree1;

Alternatively this plays with a PatternTask, not an Mdef:
: [instrument: \bass] => \synthtree1;

The advantage of Mdef over PatternTask is that it is accessible through its name for further modifications, and that it can be cloned to other Mdefs which then inherit its contents but also subsequent changes.

The ability to filter the event data broadcast by a PatternTask is implemented in PatternInstrument, and is available both to PatternTask and its subclass Mdef.

*** How Mdef clone inherits

Care must be taken not to overwrite the params that are set for the clone when the params of the prototype change.

Therefore, Mdef should have separate vars for the data from the parent Mdef, and for its own data. So it is something like:

var <parent;
var <valuePattern; // this is the currently existing variable, remains unchanged.

There is no need to store the full merged *pattern* array of the prototype with the parent *patterns*.   We only need the valueStream to be merged, since this is used to produce the event for playing.  So when a cloned Mdef receives a notification from the parnent Mdef, it goes something like this:

#+BEGIN_EXAMPLE
var keys;
keys = valuePattern.clump(2).flop[0];
parent.valuePattern keysValuesDo: { | param, pattern |
    if (keys.inclueds(param).not) { ... add only those to stream }
};
valuePattern keysValuesDo: { | param, pattern |
    ... add all params of self to own stream
}
#+END_EXAMPLE



*** Creating, chucking to synthtree

#+BEGIN_EXAMPLE
Mdef(\p1).play;  // create PatternInstrument named p1, play
\p1 => \synthtree1; // send it to \synthtree
#+END_EXAMPLE

This is no longer possible:
\instrument => \synthtree;

But this will serve as substitute:

`\instrument => \synthtree;

More examples:

Mdef(\p1, [degree: 5]); // Always (re-) initializes contents!

To not clear, but merge contents:

Mdef(\p1) set: [amp: { 0.01 rrand: 0.1 }.pfunc];

*** Modifying an Mdef: alternative shortcut =>

Mdef(\p1) set: [degree: (1..3).pseq];

or alternative shortcut:

\p1 => [degree: [1, 2, 3].pseq];

*** Modifying the received event:

**** Rejected first tries
#+BEGIN_EXAMPLE
// here we have a problem: how to indicate getting the degree:
[degree: [1, 2].pseq + ~degree] %> \synthree3;
// maybe it has to be:
{ [degree: [1, 2].pseq + ~degree] } %> \synthree3;
// or use a new type of pattern to access parent:
[degree: [1, 2].pseq + \degree.parent] %> \synthree3;
#+END_EXAMPLE

**** Solution

#+BEGIN_EXAMPLE
// alternative method name: pget
[degree: [1, 2].pseq + \degree.pget] %> \synthree3;
#+END_EXAMPLE

: \degree.pget

would translate to:

: Pfunc({ ~degree })

and that would be evaluated in the parent environment using =use:=.

#+BEGIN_EXAMPLE
parentEnvir use: {
   params keysValuesDo: { | param, stream |
      childEnvir[param] = stream.next;
   }
};
#+END_EXAMPLE

*** Cloning an Mdef (quasi Pbindf)

#+BEGIN_EXAMPLE
Mdef(\p1, [degree: [1, 2, 3].pseq]) => \player1;
Mdef(\p2).clone(\p1, [dur: 0.1]) => \player2;
#+END_EXAMPLE

Then to add further filters to a player:

#+BEGIN_EXAMPLE
[degree: 3 + \degree.pget] %> \player1;
#+END_EXAMPLE

** Fix PatternInstrument to inherit global ~fadeTime.
:PROPERTIES:
:DATE:     <2014-04-18 Fri 16:24>
:END:

** New operator =!> clear synthtree before chucking new pattern
:PROPERTIES:
:DATE:     <2014-04-18 Fri 10:46>
:END:

** EventPattern: embeddable pattern player
:PROPERTIES:
:DATE:     <2014-04-21 Mon 17:55>
:END:
Mdef/PatternTask/PatternEventPlayer should be able to embed themselves in patterns like Pdef does:

(From the Pdef help entry:)

#+BEGIN_EXAMPLE
x = Pseq([Pdef(\a), Pdef(\b), Pdef(\c)], inf).play;

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3])));
Pdef(\b, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[7, 8, 7, 8])));
Pdef(\c, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 1, 2], 2)));
#+END_EXAMPLE

*** embedInStream mechanism


Look at following methods in Pattern:

#+BEGIN_EXAMPLE
play { arg clock, protoEvent, quant;
		^this.asEventStreamPlayer(protoEvent).play(clock, false, quant)
	}

	asStream { ^Routine({ arg inval; this.embedInStream(inval) }) }
	iter { ^this.asStream }

	asEventStreamPlayer { arg protoEvent;
		^EventStreamPlayer(this.asStream, protoEvent);
	}
	embedInStream { arg inval;
		^this.asStream.embedInStream(inval);
	}
#+END_EXAMPLE

And in Stream:

#+BEGIN_EXAMPLE
	embedInStream { arg inval;
		var outval;
		while {
			outval = this.value(inval);
			outval.notNil
		}{
			inval = outval.yield;
		};
		^inval
	}

	asEventStreamPlayer { arg protoEvent;
		^EventStreamPlayer(this, protoEvent);
	}

	play { arg clock, quant;
		clock = clock ? TempoClock.default;
		clock.play(this, quant.asQuant);
	}
#+END_EXAMPLE

And in EventStreamPlayer:

#+BEGIN_EXAMPLE
	play { arg argClock, doReset = (false), quant;
		if (stream.notNil, { "already playing".postln; ^this });
		if (doReset, { this.reset });
		clock = argClock ? clock ? TempoClock.default;
		streamHasEnded = false;
		stream = originalStream;
		isWaiting = true;	// make sure that accidental play/stop/play sequences
						// don't cause memory leaks
		era = CmdPeriod.era;
		quant = quant.asQuant;
		event = event.synchWithQuant(quant);

		clock.play({
			if(isWaiting and: { nextBeat.isNil }) {
				clock.sched(0, this );
				isWaiting = false;
				this.changed(\playing)
			};
			nil
		}, quant);
		this.changed(\userPlayed);
		^this
	}
#+END_EXAMPLE

And also in EventStreamPlayer this:

#+BEGIN_EXAMPLE
	prNext { arg inTime;
		var nextTime;
		var outEvent = stream.next(event.copy);
		if (outEvent.isNil) {
			streamHasEnded = stream.notNil;
			cleanup.clear;
			this.removedFromScheduler;
			^nil
		}{
			nextTime = outEvent.playAndDelta(cleanup, muteCount > 0);
			if (nextTime.isNil) { this.removedFromScheduler; ^nil };
			nextBeat = inTime + nextTime;	// inval is current logical beat
			^nextTime
		};
	}
#+END_EXAMPLE

*** Comments / Hints

The stream must return the event to play with next

role of embedInStream not clear yet.

*** First implementation proto-draft

See class EventPattern, EventStream.

** Use embed in stream to chain (=embed) PatternTasks?
:PROPERTIES:
:DATE:     <2014-04-20 Sun 18:32>
:END:

Embedding of event-patterns done.  See EventPattern, EventStream.
For playing in SynthTree see Edef, Idef, Bdef.


** New README opening examples, starting with Edef.
:PROPERTIES:
:DATE:     <2014-04-22 Tue 15:26>
:END:

See file EdefTests.scd
** Designing Edef, Cdef, Idef, Bdef
:PROPERTIES:
:DATE:     <2014-04-22 Tue 15:26>
:END:

Edef: Associate an EventPattern with a symbol and implement propagation
of later modifications of the pattern to streams played from it.

IZ Tue, Apr 22 2014, 00:42 EEST

*** Making Edef, Idef, Bdef play
:PROPERTIES:
:DATE:     <2014-04-23 Wed 16:50>
:END:

Try making Edef subclass of EventPattern and Idef subclass of EventStream.  The reason is to implement the alternative asStream and embedInStream methods without having to add exra wrappers in a different class to handle them.

*** Operators:
:PROPERTIES:
:DATE:     <2014-04-23 Wed 16:49>
:END:

Note: here \edef and \synthree are example names.  Any symbol can be used instead to name an Edef or SynthTree.

**** Creating and modifying Edefs

Note: "propagate" means to send the changed contents of the edef to all of its "children".  Children are Cdefs cloned from the Edef or Idefs, Bdefs (EventPattern players) spawned from them.  The

\edef =< event; // add event contents and propagate
\edef =!< event; // replace event contents and propagate
\edef =<| event; // create/add event contents to edef, do not propagate
\edef =!<| event; // create/ replace old event contents by new event, do not propagate

\edef =>> \cdef; // clone edef into cdef.  cdef inherits future changes from edef.

If a function instead of an event is passed as second argument in the above,
then the function is evaluated with ~pattern as environment variable, and the
result becomes the new pattern of the Mdef.

**** Playing edefs in SynthTrees
Furthermore, the above may be chained with a chuck to a synthtree:

Going directly to SynthTree:

\edef => \synthtree; // play a new stream into a synthtree
// Stream is named after synthtree.
// Stream replaces previous stream

Initializing or modifying contents with an event, and then chucking to SynthTree:

\edef =< event => \synthtree
\edef =!< event => \synthtree
\edef =<< event => \synthtree
\edef =!<< event => \synthtree

**** Chucking events directly into synthtrees

***** event => \synthree

Chuck event to synthree's stream and play.

Always create new unnamed Bdef.

Always cross-fade.

***** event +> \synthree

Add event contents into synthree (merge).

Playing stream's event is modified.  Modifications are inherited, and overshadow (block) future modifications inherited from changes in parent Idefs or Edefs.

The values of the chucked event are evaluated in the environment of the stream's event, which means that they can be functions which access the entire event as environment.

Also accepted:

{ function } +> \synthtree

Produce new stream from existing stream and substitute new stream in the stream player.

Playing stream's event is modified

***** event +!> \synthtree

Replace event contents of synthtree's stream.  Like +>, except that the contents of the event of the playing stream are fully removed before adding the contents of the new event.

***** event %> \synthtree

Add "mod" filter - without altering contents of event stream.

A mod filter is an event contained in instance variable =mods= of BdefInstrument and whose key-value pairs are always added to each event produced by the playing stream.

This is for playing multiple synthrees with one stream, while varying the way of playing on a synthree basis.

Each key - value pair of the chucked event overrides previous values in the event produced by the playing stream.

The values of the chucked event are evaluated in the environment of the stream's event, which means that they can be functions which access the entire event as environment.

The stream's event is not modified.  These changes are strictly local to the playing SynthTree.

Durations of the stream cannot be modified by %>.

// Maybe this not!: { function } %> \synthree
// Perhaps later.

***** event %!> synthtree
:PROPERTIES:
:DATE:     <2014-05-31 Sat 16:47>
:END:

Note: Originally this was: "Replace current "mod" filter by the chucked event.  See %> for explanation of mod."

However filters do not combine.  So it only makes sense to use this operator to *remove* a filter from a key, as also noted above in immediate TODOs.

**** Named spawned stream players (Idefs)

Using symbols references to explicitly name spawned streams

***** Creating Idefs

\edef => `istream // create Idef named `istream from edef.

***** Creating Bdefs

Association is used to defer the creation of the Bdef until it is chucked to a synthtsream.  Otherwise it would become an Idef.

\edef -> `stream => \synthree // play named stream as Bdef into synthree

***** Modifying Idefs or Bdefs

event => `estream // modify estream Idef or Bdef
{ function } => `estream // modify estream


***** NameSpace

Use generator class NameSpace for named instances, instead of subclassing.

***** Modifying the eventstream or pattern with "mods"

A mod takes the event inherited from the parent and applies modifications to it in order to generate a modified Event that is used by the EventPattern or EventStream.

Analysis of mod possibilities

Possibilities 1 - 2 can coexist in any combination.
Possibilities 3 and 4 are exclusive of any other possibility.

1a. Replace a param pattern of the parent by a different pattern (possibly remove)
1b. Replace a param pattern of the parent by a pattern modifying the parent pattern
2.  Add a param pattern.
3a. Replace the entire pattern of the parent by a different pattern.
3b. Replace the entire pattern of the parent by a different pattern derived from the parent.
4. Replace nothing.

***** Inheriting process

Inheriting takes the event (pattern?) from the parent and combines it with
the mods to produce the pattern that will be used by the Edef/Idef that uses it.
It also propagates the resulting event to all inheritors.

***** How mods are modified

The mod stores the modifications to be applied for obtaining the current players event from the parent.  But when we add a modification, we change the mod itself.  In principle there are many possibilities to change a mod:

1. Replace the mod entirely
2. Remove the mod entirely
3. Remove part of the mod
4. Replace part of the mod
5. Add a new item to the mod
6. Modify an item of the mod

For the sake of simplicity, the present implementation will only handle two cases:

1. add: add the new items to the mod, replacing any items of the same name.
2. addClear: Remove all previous items of the mod, and then add the new ones.

Other operations may be added later as needed.

** Make Edef and SynthTree play with EventPattern instead of PatternEventPlayer.

Note: All inheritance/modifications should be done with Edef, its related classes Cdef (inheriting clone of Edef), Idef (inheriting named wrapper around EventStreamPlayer), Bdef (subclass of Istream that makes the streamplayer broadcast instead of playing) or SynthTree.  Keep EventPattern, EventStream as simple as possible.

*** Next things in this matter
:PROPERTIES:
:DATE:     <2014-04-21 Mon 18:47>
:END:

Wed, Apr 23 2014, 16:23 EEST: The following have been implemented by Idef, Bdef.

Possible candidate to play inside SynthTree as template?

Or a variant of PatternInstrument that listens to updates from Mdef, coupled with a different kind of Event that broadcasts itself on "play" instead of playing?  The advantage is that the PatternInstrument can then apply "filters" on the incoming event to permit playing the same event stream in different ways.

The broadcasting technique has the advantage that one can attach additional behaviors such as monitoring, sending as osc or midi, updating views etc.  to the playing event stream easily.

Furthermore, since we can nest EventPatterns, we will also want to nest Mdefs.  So an Mdef cannot be the one who plays a stream, because multiple streams may be spawned from it.  So the playing should be done exclusively inside SynthTree (also for simplicity's sake).  So the template var inside the SynthTree that is playing the event stream spawned from an Mdef is something else than an Mdef.  It looks as if it could be a variant of the current PatternInstrument with a new implementation as far as Pattern playing is concerned.

The new PatternInstrument should have:

- The Mdef it was created from (to respawn).
- The EventStreamPlayer that it is playing (so that it can start it or stop it).
- Any other synth/group/bus/SynthTree related stuff (derived from as it is now).
- The facilities for varying the way that the received events are played ("filter").

**** QUOTE How to do the broadcasting

Use a subclass of EventStreamPlayer, called EventStreamBroadcaster that uses a variant of prPlay as follows:

#+BEGIN_EXAMPLE
prNext { arg inTime;
	var nextTime;
	var outEvent = stream.next(event.copy);
	if (outEvent.isNil) {
		streamHasEnded = stream.notNil;
		cleanup.clear;
		this.removedFromScheduler;
		^nil
	}{
// Instead of playAndDelta, use broadcastAndDelta.
		nextTime = outEvent.broadcastAndDelta(cleanup, muteCount > 0, this);
		if (nextTime.isNil) { this.removedFromScheduler; ^nil };
		nextBeat = inTime + nextTime;	// inval is current logical beat
		^nextTime
	};
}
#+END_EXAMPLE

And in Event, add =broadcastAndDelta=, keeping all code, and changing only the line =this.play= to streamPlayer.changed(this), so that receivers may optionally play a modified version of the event, or otherwise react in different ways.

#+BEGIN_EXAMPLE
broadcastAndDelta { | cleanup, mute, streamPlayer |
	if (mute) { this.put(\type, \rest) };
	cleanup.update(this);
	// this.play;  // instead of this, use "changed".
        // instead of playing, broadcast, with "changed":
        streamPlayer.changed(\event, this);
	^this.delta;
}
#+END_EXAMPLE

**** Runtime modifications apply to EventStreamBroadcasters, not Mdefs (!?)


**** Coding examples

Playing an Mdef: Always creates a Bdef.

#+BEGIN_EXAMPLE
Mdef(\x).play; // plays into EventStreamBroadcaster (Bdef) of same name
Mdef(\x).play(\y) // plays into EventStreamBroadcaster named \y

// Possible shortcut:
\x => `\y;
#+END_EXAMPLE

Play into Bdef(\x) and chuck into \player1 SynthTree

#+BEGIN_EXAMPLE
Mdef(\x) => \player1;
// Equivalent to:
Mdef(\x).play => \player1;
// Possible shortcut:
\x => \player1;
#+END_EXAMPLE

Play Bdef(\y) into \player2 SynthTree
#+BEGIN_EXAMPLE
Bdef(\y) => \player2;
// Possible shortcut:
`y => \player2;
#+END_EXAMPLE

** DONE Make it possible to compose patterns with +>
CLOSED: [2014-04-29 Tue 13:40]
:PROPERTIES:
:DATE:     <2014-04-24 Thu 18:09>
:END:

Done in Idef addEvent.  Example:

#+BEGIN_EXAMPLE
(degree: (0..7).pseq, dur: 0.25) => \test;
//:
(degree: { Pstutter(3, ~degree) - [2, 1, 0].pseq }) +> \test;
#+END_EXAMPLE

** DONE Make it possible to compose patterns with +>
CLOSED: [2014-04-29 Tue 13:40]
:PROPERTIES:
:DATE:     <2014-04-24 Thu 18:09>
:END:

Done in Idef addEvent.  Example:

#+BEGIN_EXAMPLE
(degree: (0..7).pseq, dur: 0.25) => \test;
//:
(degree: { Pstutter(3, ~degree) - [2, 1, 0].pseq }) +> \test;
#+END_EXAMPLE

** CANCELLED Make it possible to compose patterns with %>
:PROPERTIES:
:DATE:     <2014-04-30 Wed 00:14>
:END:

Not applicable, because the values received from the playing EventStream are final ones - the result of playing the Stream.  It is however possible to use a preexisting stream to compute new values and combine them with the value from the event.

#+BEGIN_EXAMPLE
(degree: (0..7).pseq, dur: 0.25) => \test;
a = [0, 3].pseq.asStream;
(degree: { ~degree + a.next }) %> \test;
#+END_EXAMPLE

** UNSOLVEABLE \symbol.ar breaks audio routing in Ndef/SynthTree
CLOSED: [2014-05-02 Fri 15:36]
:PROPERTIES:
:DATE:     <2014-05-02 Fri 11:14>
:END:

It was not a bug, but a deeper problem that also concerns Ndef:

Use of \symbol.ar inside a source Ndef / SynthTree breaks the linking to the fx once the source has been started.

** amp default should be 1. Use 'level' instead? Range 0-2, db?
:PROPERTIES:
:DATE:     <2014-05-01 Thu 11:06>
:END:

** \in.ar -> \in.in
:PROPERTIES:
:DATE:     <2014-05-01 Thu 11:04>
:END:

See JitOps

** CANCELLED \symbol.kr default lag 0.2?
:PROPERTIES:
:DATE:     <2014-05-01 Thu 11:08>
:END:

To avoid zippering.

** DONE Revise Edef to simplify spawning/playing behavior
CLOSED: [2014-06-07 Sat 09:37]
:PROPERTIES:
:DATE:     <2014-06-06 Fri 11:33>
:END:

This:

: \pattern1 =< (degree: 1)

Should create Edef =\pattern1= if it does not exist, else add the keys of the event to the existing Edef, and finally it should start playing the Edef if it is not playing.

This:

: \pattern1 ==< (degree: 1)

Should prevent starting to play if the edef is not already playing.

*** Should Edefs also have a gui like synthrees?

*** \edef.clone? \synthree.clone?

** DONE replace =< by => for ST linking
CLOSED: [2014-06-18 Wed 01:34]
:PROPERTIES:
:DATE:     <2014-06-17 Tue 12:33>
:END:

Examine if this works:

\st1.st => \st2

instead of
\st2 =< \st1

Previously the order was reverse, to permit starting the receiving fx before the sending source, because the fx must be started first to set its group, to be ready for the source.  However, this can also be coded in reverse order through following mechanism:

: { source } |> \st1 => ({ source } |> \st2) => ({ source } => st3)

Where:

: { source } |> \st1

... sets the SynthTree up to play source, but does not start it

: => ({ source } |> \st2)

... also sets up st2 but does not start it, but additionally => tells the receiver (\st1) now to wait for \st2 to start (through notification changed(\started)), and then to start!  And so on for st2 to st3.

** DONE Draft of OSCMap
CLOSED: [2014-06-18 Wed 11:33]
:PROPERTIES:
:DATE:     <2014-06-18 Wed 11:33>
:END:

** DONE onObjectClosed, Registry remove on object closed
:PROPERTIES:
:DATE:     <2014-06-19 Thu 10:44>
:END:

Registry removes object when it calls objectClosed.


** DONE generalized slider scheme for st
CLOSED: [2014-06-19 Thu 13:20]
:PROPERTIES:
:DATE:     <2014-06-19 Thu 13:19>
:END:

See file GenericGUI.sc, and examples in Examples/SliderExamples.scd

* Undergoing tests

** =SynthTree=: Storing/interconnecting Synths

ChucK-style operators: =>, variants: =<>, ==>, =<, =^.

** =Pub= (previously defined as =Source=) Flexibly connect objects to data sources

Publish data received from a source (PatternTask, OSCFunc, MIDIFunc, GUI) to any object that is concerned. Able to:
- Replace the origin of the data source at any time.
- Work interchangeably with Patterns/Streams, Views, OSCFuncs, MIDIFuncs, constant values.
- Customize, map and/or filter the messages and values sent to listening objects.

Note: Previously (Wed, Mar  5 2014, 17:08 EET) this class was called =Source=.  But this created confusion, because the Source actually publishes to many objects the results of polling another object, which is the stream *source*.  So it would be better to call this class "Publisher", or for short: "Pub".

*** Basic method: =pub= (previously =src=)

: anObject.pub(source, mapper);

Get or create a Source instance, and connect its output to anObject.  Return the Source instance.  The way in which the output is connected to the receiving object is set by the mapper, which encapsulates both any processing of the value received such as mapping it with a spec, and the message to be sent to the receiver, such as =.set(\freq, mappedValue)=.  For example:

: anObject.pub(source, [500, 600].mapSet(\freq));

The above makes the object =source= send to =anObject= (usually a Synth instance), the message =set= for setting parameter =freq= with a value mapped from an input in the range of 0-1 to the range of 500-600.  The source can be any object that generates values in time, for example a Task (Routine not supported yet), an OSCFunc, a MIDIFunc, a gui Slider, etc.  The object given to method =pub= as its =source= parameter can be either a symbol for accessing an already existing Source instance from a global dictionary, or a template that is used by Source to create a Source instance which will broadcast the generated values.

Here are the steps of this mechanism:

1. Find or create the source instance.
   - If =source= is a symbol, then get the source instance from the dictionary in Source.all.  If no instance is found under the given symbol, then create one.
   - If =source= is an instance of Source, proceed to the next step, connecting =source= to =anObject=.
   - Otherwise create an instance of source using the object as source of values.  The object given in =source= is treated differently according to its kind:
     - pattern: create a Stream from pattern.
     - view: set the action of the view to do source.changed(... view.value).
     - OSCFunc: set func of OSCFunc to do source.changed(...).
     - MIDIFunc: set func of MIDIFunc to do source.changed(...).
     - SequenceableCollection: Pseq(collection, inf).asStream, polled at intervals given by Source.pollRate.
     - Any other object: return routine polling the object with object.value(source)
       and broadcasting the resulting value to the listeners of the source.  This also works for Functions.  Use classvar pollRate of Source as polling rate.

*** Shortcut: set parameter of Node from values (NOT YET IMPLEMENTED)
 A special case/shortcut method for setting the parameter of a Node (Synth or Group):
: aNode.rset(routname[->parname], valueStream, timeStream);

- =parameter/controller= :: A symbol or an association parameter->controller. =parameter= is the name of the parameter of the synth to be set by the routine. =controller= is the symbol under which the routine is stored. If no controller name is given, then the controller name defaults to the parameter name.
- =valueStream= :: Any object.  Values are obtained from the stream by sending it the message next.  Patterns are converted to streams with asStream before being used.
- =timeStream= :: Any object that returns a stream of positive integers (duration values) when sent the message next. (Similar to valueStream).

*** first prototype - polling streams with a routine and timing
The routine is created rougly like this:

{
	var val, dur;
	while { (val = valStream.next).notNil and: { (dur = durStream.next).notNil } }
	{
		thisThread.changed(\value, val, dur);
		dur.wait;
	};
	this.changed(\p_end);
}

The controlled Synth may choose to =free= or =release= itself when receiving =\p_end= at the end of the routine process.

*** Details: encapsulating routines and other data sources

Source Encapsulates the routine in another object that sends the notifications, so that one may substitute a new routine in that object and still keep the connections to all listeners controlled by the object.  It can hold any object that wants to broadcast a stream of values, such as a poller of audio or control stream values, a tcp poller, an osc or midi event listener, a gui widget event listerer etc.  Finally, the listening objects receiving notifications from the Source instance can use adapters to react differently to the data received.

** =MapFunc= Encapsulate mapping action and sending message to listener

Encapsulate the spec in the mapping function, thereby saving the trouble to store specs in an extra variable.  Also exchange mapping or other type of response functions at any moment, without having to store these actions anywhere.  Use =Object:removeNotifier(notifier, message)= to remove the previous instance of the notification and replace it with the new one.

Variables of MapFunc:

- source :: object that sends the values
- listener :: object that receives the message and converted value from the update.
- mapper :: function or other object that processes the values received from the source and sends them to the listener as a message (=listener.perform(*args)=). Other types of responses to =value= are implemented by specialized subclasses of =MapFunc=.

The three items above can be useful to the =MapFunc= as sources of further information or targets of further actions when performing its action.  Therefore the action is passed the MapFunc instance along with the value, so that it may retrieve further info from the listener or notifier, or perform other actions on them or remove itself etc.

- action :: function that maps or otherwise acts on the value received from the update.  Note: A spec does not need to be stored separately, because it can be made available to the function through a closure created by another function that creates the action function.  The action returns an array whose first element is the message to be performed by the listener and the rest of the elements are arguments to that message.

*** Connecting an object to an updater (Pub)
NO LONGER VALID!:
Message for connecting an object to an updater (Pub) - yet see next subsection below!

: specF(action)

Action can be constructed by messages to Arrays, Functions, or other types of objects.
For example =\freq.asSpec.setter(\freq)= would return a function that returns an array:
=[\set, \freq, mappedValue]=.  Or this could be further abridged to: =\freq.mapper= where the name of the parameter to be set defaults to the receiver.

Here is maybe a better version:

*** Shortcuts for connecting an object to a Pub:

Use standard prefix v (variable) or s (source) for the method names.  For example:

=vmap= is for variable map, where map is from the map operation in Lisp, which operates on each value of a collection (in this case, the stream of incoming values).

=vmap= is sent to a Symbol.  It creates a MapFunc instance, named after the symbol, without an action.  The action can then be set by sending the instance messages. Such messages are described in the next section:

*** Shortcuts for creating mapping functions

- =map= :: Create a function that sends the listener the message set thus: =listener.set(parameter, mappedValue)=.  The parameter can be provided as argument.  The spec for mapping the input value is also created from data passed as argument.
- =unmap= :: Like map, except that the spec is used to unmap instead of to map.
- =bimap= :: Like above, except it uses a custom class =BiMap= (see Lilt2 library) to map from aaaaany custom range to any other custom range.
- =args= :: evaluate each of the args passed to this function each time with the value received, collect the resulting array, and send it as message to the listener thus: =listener.perform(*args);
- =select= :: only send message with (mapped?) value when the value satisfies a condition.
- =reject= :: only send message with (mapped?) value when the value does not satisfy a condition.

Here some earlier drafts with details - not entirely consistent with the above.

Examples:

=set= creates a function that sends the set message with the value mapped through a spec produced from a specPrototype, guesses the parameter name from the prototype, or gets it from paramName, and optionally inserts restargs between the parameter name and the mapped value.

: listener.vmap(source).2qset(specPrototype, (optional:) paramName ... restargs)

#+BEGIN_EXAMPLE
// listener.vmap(source) does the following:
var mapFunc;
mapFunc = MapFunc(listener, source);
listener.addNotifier(source, \value, mapFunc);
^mapFunc;
#+END_EXAMPLE

The returned mapFunc is used to construct the action by sending it

Most general case: collect the result of evaluating each of the args with the value as argument, and send it to the listener with listener.perform(*args). Thus, even the message sent can vary according to the input.  We may use a special message =null= defined for Object, to send any object messages that should be ignored (null method).

: vmap(source).send(... args);

For example:

: aSynth.vset(aStreamPub).spec(\freq);
: aSynth.vset(aStreamPub).spec([10, 100],

Seletive action constructors could be defined:

: vselect(source).select()
: vreject(source).reject()

** PatternTask: Play a pattern, as stream, getting durations from another pattern

The timing of successive value requests from the stream is defined by another stream,
that produces the dt (time intervals) to wait for the next call of "next".

Patterns of both values and durations stream can be exchanged on-the-fly while the player is running.

Used by Pub as default source for all objects except OSCFunc, MIDIFunc and View.

* Next plans:

** Playing patterns in a SynthTree

*** Idea 1: args envir w. StreamPatterns

Store args for synth in an Event, in args variable.  These can be used to start synth.

But they could also store streams.  In this case, each time the synth starts, it starts with the next set of values from the arg event's streams.  Then the template could also be a stream possibly returning different instruments at each call of next.

In order to be able to reset the streams from the patterns, store each stream together with its pattern in a new Class: StreamPattern.

Each StreamPattern can play with its own Task (see PatternTask).  The latest value produced by =next= on the stream is stored in var =next=, so that it can be accessed each time that a synth is created, without asking the stream itself to produce a next value.  When asked next, the StreamPattern decides whether to use the already produced next (if its Task is running), or to return the next value in the stream (if no Task is running).

Or they could be busses instead - in which case they map the synths arguments.

They could also be substituted by or combined (BinOp) with controllers (GUI, MIDI, OSC, other), received via =Pub= updates.  Similarly, they could be linked to updates issued by streams in other synths or global shared Pub updates.

*** Idea 2: =SynthStream=: Alternative to Pbind
 Pluggable inside a SynthTree instead of a Synth.

 Allows exchange of data-streams for parameters on-the fly (JitLib style, but without the busses and possibly simpler). SynthStream should be visible to the SynthTree like a Synth (interface-wise).  It could be a subclass or variant of PatternTask.  Its valueStream would be an environment (or even event) from which the arguments of the next synth are collected.  Fade-in and -out can be implemented by hijacking the ~amp stream, and setting it to poll a control-rate env or line synth on bus private to the stream.  Optionally, additionally, at the same time mapping the amp of each synth, after creating it, to the same amp bus.

** CBoard

Add/remove widgets dynamically in a single gui window, for display and control of processes.  The window can be placed at one of the 4 sides of the screen.  Show just the widget with a label.  Default widget: Knob (for compactness).  More functionality accessible by typing keyboard commands at a selected window (possibly with ctl key):  Start/Stop the related process, input a new source-template for the process, etc.

Each window stores the widgets in a dictionary under the names of the labels, for access.

*** Interleaved control from multiple sources on one Pub

** SourceTree: Edit trees of sclang processes
See:
file::./classes/ProcessComposition/ProcessCompositionNotes.org

SourceTree: Language and representation of trees of event sources (Patterns/Streams, OSCFuncs, MIDIFuncs etc) composed with operators to Pbinop and BinaryOpStream.

Add, remove, replace any element of the tree by giving its address as a symbol composed of =l= and =r= for specifying the movement down the branches of the binary tree.

* Started, but currently on hold

** MixBus class

This idea may be implemented better as an extension of the NodeTree idea.

Subclass of Bus.

MixBus(name, numChans, out); // create new instance if needed, and make it current.

Alternative for above:
\name.mixBus(numChans, out);

Also creates its own Group.
When created:

- registers itself in MixBus.all class variable under its given name (symbol), for access.
- sets the following current environemnt variables:
  - ~out :: index of the bus. Synths can write to this bus.
  - ~target :: its group
- Creates synth called =gain= positioned after =~target=, providing:
  - global level control (control name: =gain=)
  - adsr envelope for fadeout with method =release(releaseTime)=
- The =gain= synth directs its output to another channel, per default channel 0.
- Different types of =gain= synths can be used, to provide effects and multichannel output
- Other synths can be added before =gain= to provide additional effects.
- Syn(...) reads ~out an ~target from the environment, and therefore by default uses the installed MixBus, if present.
- Define keyboard shortcuts in SC for altering the level control of the current mixbus (the one belonging to the current environment).
- Create GUI for MixBus.  The gui can show all mixbusses stored in MixBus.all.
- The =gain= synth can be released to shut output of a mixbus.  A new gain synth can be created at any moment to restart output, or even to crossfade a different type of output.
- To remove a mixBus entirely call mixBus.remove.  This releases the gain synth, removes the group when the gain synth is freed, removes the mixBus from the =all= variable, and frees the bus.

** More convenient ways to map Synth parameters

*** Synth:busctl : map parameter to a bus to which a synth outputs.

(note: older name of method was =nmap=).

: aSynth.busctl(busname[->parname], controlSynth)

This method maps a bus stored under a name =busname= to a input parameter (control) of the synth being controlled. =parname= is the name of the parameter to which the bus is mapped.

- =busname[->parname]= :: A symbol =busname= or an association =busname->parname=. If no =parname= is given, then =busname= is used as the name of the bus to which to map and the name of the parameter that this bus will be mapped to.  If an association =busname->parname= is given, then =busname= is the name of the bus and =parname= is the name of the parameter to which the parameter is mapped.
- =controlSynth= :: A control-rate synth to be mapped.

For example:

: { SinOsc.ar(\freq.kr(400), 0, 0.1) }.play
: .busctl(\freq, { LFNoise0.kr(5).range(400, 500).out }.play);

Outline of actions done by this method:

1. Access bus as value in a global dictionary of Synth-bus or symbol-bus associations.
2. Create new bus if not already present, and set output of controlSynth to bus index.
3. Map parameter to index of bus.

Note: bus should/may be freed and removed from global dictionary when all of its synth inputs are freed.

* Further Plans:

- Org-table as score?
- Add to sclang-snippets:
  - Each snippet eval output is stored in list of objects, in emacs buffer,
    for access, eg. to free or pause a synth, routine, group, pattern player etc.
  - If return value is synth: store synth
  - If return value is routine: create own group for putting synths in,
    so that synths are also freed when routine is stopped?
    Possible?  Only via currentEnvironment.  Use variant of Synth.new
    to access currentEnvironment's target?
    This could be method synth of string or symbol, called in similar manner as Synth.new:
    Instead of Synth("test"), write synth("test").
  - Similar to routine, also for Pbinds.
    Check if Pbind accesses currentEnvironment to get \target value.
    If so, then implementing private group per snippet should be easy.

* Implementation notes

** Stopping processes started from code contained in an org-mode section

Pass the id of the current snippet/section as environment variable by enclosing the code to be evaluated with =sc-lang-eval-string= in a function evaluated within a new environment.

#+BEGIN_SRC elisp
  (sclang-eval-string
     (concat
      "(source_id: '"
      (org-id-get-create)
      "', eval_id: UniqueID.next) use: {\n"
      string
      "\n}"
  ))
#+END_SRC

Storing the ID-process correspondences in SC: Store each process in an instance of NamedProcess, with its org-section (source) ID and eval ID (the number of times that this snippet is currently running).

The eval id is stored as property in the org-section.

** Process trees?

To kill all child-processes of a Routine one may add thisThread as notifier to a child process (Node or Routine or EventStreamPlayer) and notify the children when the thread stops.  Similarly for EventStreamPlayer.  Registering processes under a snippet/org-section id is a simpler alternative. However process-tree based stopping is a different thing, because one may want to kill a parent-process through the gui, independent fom the snippet grouping which may contain also other processe
