(Copied here on: Sun, Mar  9 2014, 20:37 EET)

* Currently working on

** New approach to try: Implement the current operators for synths and patterns using Ndef, Pdef and related JITlib classes, to locate overlaps and possible differences.
:PROPERTIES:
:DATE:     <2014-04-28 Mon 22:12>
:END:


** TODO Make it possible to compose patterns with +> and %>
:PROPERTIES:
:DATE:     <2014-04-24 Thu 18:09>
:END:

Currently only functions are possible.

Must see previous solution in Mdef and correct the methods related to this.

** Both single-synth and synth-stream should play with PatternInstrument
:PROPERTIES:
:DATE:     <2014-04-18 Fri 16:24>
:END:

 - SynthTree.legato (SynthTree.l) :: play with Pmono-like event.play function
 - SynthTree.nonLegato (SynthTree.nl) :: play with usual event.play function

To consider: Should legato also play in bus like non-legato?  That would provide consistent fadein-fadeout and simplify coding, but waste bus...

** fix ref chuck to synthtree symbol
:PROPERTIES:
:DATE:     <2014-04-18 Fri 16:39>
:END:

If the instrument is a single synthdef, one may chuck it directly in the tree:
#+BEGIN_EXAMPLE
`\sine => \test2;
#+END_EXAMPLE

** play data streams
:PROPERTIES:
:DATE:     <2014-04-07 Mon 11:44>
:END:

- as full events, single synth per data vector

- as streams of st.set(param, nextValue)

- as envelope-like shapes playing in synths and outputting in control or audio busses

Try these with arrays loaded from data analysed through SCMIR.

* Immediate TODOs

** PatternPlayer: Retain because more lightweight? Rename to PatternTask to avoid conflict with Conductor Quark.
:PROPERTIES:
:DATE:     <2014-04-25 Fri 19:29>
:END:

PatterPlayer is still used to play single parameters of a synth in a synthree, but it could be replaced by a Bdef/BdefInstrument which also sends values, and allows greater flexibility.

But note: Bdef/BdefInstrument are much heavier.

Maybe rename PatternPlayer to PatternTask!!!


** Implement @> for mapping control busses to synthtree params

** Use Linen for adsrOut

adsrOut => linOut;

Adsr is superfluous.

** SynthTree:

*** fix ==> n_free Node not found when =< to fx

Note: this is a glitch only.  ==> works fine, but Server sends notification warning n_free Node not found.
*** operators for: insert synth between, replace input

=^ replace previous input by this one (for example to switch input between audio in and a buffer playback, or between different buffer playback synths etc.

=^< insert synth specified by right operand between the left operand's synth and the synth of the tree specified by the symbol adverb.

*** Further:

- Test added cycle check to method addInputSynth
- =<> should set the amp of the SynthTree to 1.
- Implement fade-in by setting Adsr's attackTime value at synth creation time.
- Set operator: *>
  - =440 *>.freq \mySynth;= // set freq of mySynth to 440.
  - The *> operator may work also with busses, synths, patterns, MIDIFuncs, OSCFuncs, Views, or pubs.  However see criticism and alternative formulation in next section.
    - Bus: map to the bus
    - Synth: create bus and map to it (?) (such buses should be registered in server-global dict like SynthTrees?)
    - Patterns, etc.: make pattern or other object set the named parameter whenever it produces a new value.
    - Use messages =map=, =unmap=, =bimap= to create mappers for updating objects.  The mappers are stored in the args var of the SynthTree, so that different SynthTrees depending on the same updating object (pub) may use different mappers/specs.
**** Alternative formulation thoughts for the set operator above:

The above will only work well for setting params maybe we don't want it at all.  mySynth.set will do?  We only save the parens, I think.  S

Need to specify 3 things:

1. parameter operated on
2. operation
3. position in binop tree where the operation will take place

Also need to accommodate both busses and buffers, with name access.

\mySynth @ param <operation>.<position> <right operand/new element>

{ } => \mySynth @ param ...

Finally, better use message style, because clearer, and also chainable:
#+BEGIN_EXAMPLE
\mySynth
   .set(param, val)
   .out(param = \out, chans = 1) // creates bus ref
   .in(param = \in, chans = 1) // creates bus ref
.view(param, name, view ...) // name etc. optional. creates knob per default
// NOT:   .view(param, nameOrView = param, storeName = \view)
   .osc(param, specs = param, storeName = \osc)
   .buf(name, param, chans) // creates buf ref
   .midi(param, specs, storeName = \midi)
   .map(name, param, chans) // creates bus ref
   // following compose patterns / streams. for later? ... ?
   .add(param, element, storeName, path);
   .sub(param, element, storeName, path);
   .mul(param, element, storeName, path);
   .div(param, element, storeName, path);
   .mod(param, element, storeName, path);
   .pow(param, element, storeName, path);
   .sel(param, element, storeName, path);
   .rej(param, element, storeName, path);
   .fun(param, element, storeName, path);
   .choose(param, element, path);
   .wchoose(param, element, path);
#+END_EXAMPLE

**** StreamPattern methods / operators?
  - Pattern.play(durationPattern);
  - SequenceableCollection.play(durationPattern);

** Global Streams, StreamPatterns, Patterns, PatternPlayers

Patterns, Streams, StreamPatterns and PatternPlayers should be stored globally each in its own dict, and added to any number of SynthTrees.  One SynthTree might want to compose the stream source used by another SynthTree with a second stream source!

They could be stored in / accessed from the global Library.

How many categories should exist?

- Patterns :: Used to spawn streams that go directly in a MultiControl stream, privately
- Streams :: Used to store streams for global access.  Cannot respawn. Note: sharing streams as sources of values in different SynthTrees problematic (cannot call next twice - who calls first? See note below: "Important:", and next section, StreamFunc for solution of this problem).
- StreamPatterns :: Like streams, but can respawn their stream when ended.  Multiple access problem of Streams also apply here.
- PatternPlayers :: Play patterns in time.  Can be distributed to multiple patterns via Notification.  Play independently of Synth start, therefore no synchronization problem.

Important:  Calling "next" on demand at synth start: Cannot ask the same stream to share with multiple events.  How to synchronize/distribute?  Common pattern player for many synth-trees?  The solution is to broadcast a stream's values with 'changed' method calls, and catch them in similar manner as a ViewFunc does (i.e. like an Responder).  Call this StreamFunc.  One can define FilterStreamFunc as a subclass of StreamFunc, to process the incoming values of with either a function or a FilterPattern, also creating BinOp trees for composing different operations on the incoming value.

** StreamFunc

see above.  (more to come)

*** PatternPlayers vs SynthPlayers
PatternPlayers play a single stream

SynthPlayers play a SynthTree in Pbind-like manner.  They enclose the created synth events in a single group private to the SynthTree, divert the synths to a private bus, which is then processed by a synth that provides amplitude and fadein/out control.

** Map synths to params via busses
:PROPERTIES:
:DATE:     <2014-03-23 Sun 21:48>
:END:

Map synths playing envelopes, any function, lines to input controls of other synths.  See SynthTree:map, SynthTree:fade.

** Improve keyboard commands for setting fadeTime

* More TODOs

** Review / remove use of changed(\value) in PatternPlayer
Could a function be called directly instead, to save CPU cycles?

** EventList class

(Earlier version done in Lilt2 lib: Chain).

Instead of holding the lists (streams) of value events and durations separately, each event holds its own duration together with the data in one object.  This is good for editing event chains by cutting-pasting, inserting events or event lists to change lists or to create other lists.  May be good also for displaying event lists as a graphic score.

** Possible shortcuts for params
Draft of how this looks in code.  Different things that one could do with a synth parameter by addressing it (as MultiControl instance) through the environment:
#+BEGIN_SRC
0.03 => ~amp;
660 => ~freq;
~freq.slider;
~freq.knob;
~freq.numbox;
~freq.numSlider;
~freq.knobSlider;
~freq.oscFunc(...)
~freq.midiFunc(...);
~freq.pattern(...);  // or: ~freq.pp(...);
<a pattern player> => ~freq;

\anotherSynth.push; // switch to another SynthTree for working ...
#+END_SRC

IMPORTANT: Maybe use another operator for chucking stuff to a SynthTree *without* making it current.  Unclear yet how this all works together when for example chaining several fx synths.

*** Analysis: possible operations on parameters.
:PROPERTIES:
:DATE:     <2014-03-29 Sat 16:43>
:END:

~st: current SynthTree: => operates as usual, chucking into SynthTree.
~fx: current effect.  Can be used with =< to add new input.

All other environment parameters will return a multiparameter instance controlling one of the synthree's parameters.

There are following possibilities of chucking something to a synthree parameter:

- number :: set the synthree parameter to that number
- bus :: map the parameter to that bus
- pattern or stream :: play the pattern or stream into that parameter
- array :: convert array to pseq with inf repeats and play??????
- function :: play it into bus and map the parameter to that bus
- view :: set view to contol parameter
- OSCFunc: set func to control parameter
- MIDIFunc: set func to control parameter
- Buffer :: set bufnum to the parameter for playing the buffer
- Event :: set all params and restart.

**** Constructing pattern players
Shortcut method for turning Function, pattern, array, or stream into a patternplayer for playing into the parameter: =pp=!

Alternative operator for constructing a pattern player (instead of =pp= method): Chuck:

: <values: pattern/func/array> => <durations: pattern/func/array/number>

So one can go:

: <values pat> => <durations pat> => ~freq

To construct a pattern player and play it in parameter =freq=.

One could also use this with an event, in which case there are 2 possibilities:

1. Play all associations in the event as parameter-value pairs, with the values forming streams, pbind-like, playing new synths at each new evaluation of the pattern's values.
: <event> => <durations pat> => <SynthTree>

2. Do not play new synths at each evaluation, but just set the parameters of the synth.

: <event> => <durations pat> =*> <SynthTree>

Additionally, for case 1, one may use a special instrument name such as \slur or \portamento, or '*' or '-', to skip a new synth and set the parameters of the current synth, behaving as in case 2.



**** Chucking into busses

- =<function> => bus= :: play the function to that bus
- =<envelope> => bus= :: play the envelope to that bus
- =<UGen> => bus= :: convert ugen to synth and play in that bus.  Good for playing Line.kr.  But this could be done with something like: ~amp.fadeTo(...);


*** (Older:) PatternFunc notes

#+BEGIN_EXAMPLE
<pfunc template> %> 'pfunc_name' *>.param_name SynthTree_name;

<pfunct template %> 'pfunc_name'; // creates PaternFunc and binds it to name

Alternative:

'pfunc_name'.patternFunc(<template>);
'pfunc_name'.pf(<template>); // shorter form

// also:

<pfunc template or name> *>.param_name syntree_name;
#+END_EXAMPLE

The operator *> could be a multi-purpose operator for binding any type of func (osc-, view-, midi-, pattern-funcs) to a parameter.  It could also alternatively be coded with the messages already started:

#+BEGIN_EXAMPLE
<SynthTree or name of SynthTree>
    .osc(param, <template or name>)
    .midi(param, <template or name>)
    .view(param, <template or name>)
    .pattern(param, <template or name>)
#+END_EXAMPLE

Further notes (originally written in PatternFunc.sc draft):

Binding a MultiControl to a PatternFunc:

- Store the patternfunc under its name in the multicontrol dict. (maybe construct name from name of param ++ name of pattern func to avoid conflicts?.  Must rethink idea of multicontrol as dict, and the problem of naming.  Perhaps there exist alternative names for managing access to different controllers of a multicontrol, that do not involve names?)

- Attach self to patternFunc via a notification action that goes something like:

this.addNotifier(patternFunc, \value, { | value |
	this.set(value);
});

Different actions could be added instead of { | value | this.set(value) }.
These could process (modify) / select / reject the values to be sent to the parameter, and could be composeable with binaryOps.  So one goes:

multiparam.pattern(<template or name> <operator> <filter>);
alternatively with messages:
multiparam.pattern(<template or name>.add|mul|map|unmap|select|reject(<filter>));

**** Playing SynthTree events with PatternPlayer/PatternFunc
Important: Alternatively, a PatternFunc may store as currentValue an event with many parameters, and SynthTrees receiving notifications from it could play that event each in its own way.

One could thus bind a whole SynthTree to a PatternFunc with the same operator:

<patrernfunc or name> *> <SynthTree or name>

When no parameter is given as adverb to the *> operator,
then the patternfunc is bound to play the whole SynthTree.

Alternatively:

<SynthTree or name>.patternPlay(<patternfunc or name>);
shorter form:
<SynthTree or name>.pp(<patternfunc or name>);

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Possible class group for playing patterns in SynthTrees, in Pbind-like manner:

- PatternPlayer: generates and broadcasts event values for any listener
- PatternFunc: Listens to and filters event values for a SynthTree.
	Is stored in the template var of SynthTree
	holds: The PatternPlayer ...
- PatternSynth: Encapsulates synths generated by patternfunc. Holds:
	- the synths
	- possibly a group and bus to fade/adjust gain of the whole output signal
	- the PatternFunc

See also: BasicIdeas.org, Extending AbstractResponderFunc paradigm -> Generalizing Responders -> Example 2: Playing Patterns.

*** SynthTreePlayer draft notes
- Should work as a template and as a synth (same instance?) in SynthTree.
- Should keep its synths in own variable, allowing for playing of multiple synths at the same time.

See also PatternPlayer ...


* Done

** Before [2014-03-12 Wed]
- Adsr, Sine, Perc :: Env shortcuts
- out, adsrOut, Inp :: =Out.ar=/=kr= + =adsr=, =In= shortcuts.
- Notification :: Filter "changed" notifications, add and remove notifiers.bb
- ProcessRegistry :: Keep track of running Nodes, Routines, Patterns.
- ProcessRegistryGui :: Display list of running processes, =delete= key stops selected process.
- sclang-snippets :: Shortcuts to navigate, select and run code blocks separated by =//:=.
- org-sc :: Evaluate SC code in org-mode sections and babel blocks.
  - Eval code in sections, replace/stop processes belonging to a section
  - Wrap code in Routine to permit using =wait=, and play loops.
  - Load all sections whose AUTOLOAD property is non-nil.
  - Store processes under a key representing the snippet or org-mode section from which they were started.  Thus make it possible to stop or replace the processes that belong to the current snippet or org-mode section.  For sections: Use the org-id ID as id and the name of the section for display.  For snippets: Generate name if not present in =//:= header, add number if not unique.
  - Load org-mode sections marked with AUTOLOAD property.
- Replaced old README with another one, that is less technical and more hand on.  The README consists of examples, where each example is brief and can be executed immediately with audible results to show what the library does.  For each example there should be a brief description, accompanied by pointers to the related parts of the library, where more information can be found.
- SynthTree:
  - Store all root-level SynthTrees as inputs of a \root SynthTree, for each server.  Use the =root= SynthTree to iniTree the entire tree of a server.
  - Tested connecting synths.  But changing sources of connected synths is still broken.
  - Added methods =synth=, =isPlaying=, =inputs=, =output=, =args= to Symbol.
- Test linking synths: What happens when chucking a new synth to the reader?  To the writer?  Subtests are:
  - Debug  node not found when linking more than 1 synth or at initTree.
  - Test initTree when the tree contains linked synths
** SynthTree.initTree: Do not check for playing synths
:PROPERTIES:
:DATE:     <2014-03-12 Wed 07:28>
:END:

** ViewFunc->UniqueViewFunc

Test new version UniqueViewFunc and substitute UniqueViewFunc in MultiController: view instead of ViewFunc.


** Debug MultiControl:view

Following only controls freq.  View does not control amp.

#+BEGIN_EXAMPLE
\asdf.view(\freq);
\asdf.view(\amp);

{ LFTri.ar(\freq.kr(400)) } => \asdf;
\asdf.set(\amp, 0.02);
#+END_EXAMPLE
** symbol.buf(...)

** BufferFunc

How to get buffers:

- BufferFunc(listener, buffername, server) :: make buffer named buffername available to object listener for use as synth parameter.  The parameter is the listener.   Lookup buffer at the global Library, under path [buffers, server, buffername], ask for path and load if needed.

Algorithm draft:


- Lookup buffer in library under [\buffers, server, name].

- if not found,
  - notify [return?] index of default empty buffer (preallocated).
  - open dialog box for selecting file to load
  - read buffer and immediately also:
  - register it in the library so that others can find it
  - set its numframes to -1 indicating that it is being loaded still, therefore do not reload
  - register info action of buffer read to notify self when done
  - upon receipt of info from server, notify index of new buffer, so that synths may set it.
  - register buffer in library.
- if found
  - if info of buffer has numframes > 0 (i.e. it is loaded), then return/notify index of buffer.
  - else if info is -1 then
    - register self for notification when buffer has been loaded
    - use empty buffer in the meanwhile

Upon server real boot:
- allocate default empty buffer with 256 frames mono, for use while buffers are being loaded.
- for all buffers registered in library for that server:
  - read the buffer and immediately also:
  - set its numframes to -1 indicating that it is being read.
  - get info and notify all dependants when the buffer is loaded, so that it may be used.

[possibly register all buffers in a sort of queue and notify when the queue is empty, and do SynthTree:initTree after that!!!]

** Debug SynthTree:trig:

Restarting this with ==> leaves the old synth hanging
Solution implemented: Use =|> instead of ==>

#+BEGIN_EXAMPLE
{
	var synth;
	synth = { SinOsc.ar(\freq.kr(400)) } =|> \test;
	10 do: {
		synth.trig(\freq, 400 rrand: 1200);
		0.25.wait;
	}

}.fork;
#+END_EXAMPLE

** SynthTree mixer: pnel of SynthTrees with amp faders.
:PROPERTIES:
:DATE:     <2014-03-20 Thu 11:34>
:END:

** Add key commands to SynthTree faders
:PROPERTIES:
:DATE:     <2014-03-23 Sun 21:48>
:END:

- , :: Stop running processes
- . :: Stop running processes and clear SynthTree (set all to stopped)
- i or / :: init tree = restart processes
- space :: toggle selected SynthTree: start/stop

** stop+clear tree command
Add kbd command to free the entire SynthTree and set all nodes isStopped to true.  This is good instead of Command-. to make sure that no unwanted SynthTree nodes will be restarted.  Proposed key binding: =C-c C-x C-=.

** Palettes of components for dragging onto fader gui

: Palettes.show;

Keyboard command on Emacs?

Possibly: H-c H-p ?

*** org-files with lists of SynthDefs, Functions etc.

To be stored in dicts with symbols, from which guis are created to use these with drag-and-drop onto the SynthTree fader gui or onto the Knobs gui.

** Templates

Predefined SynthDefs or Synth Functions and PatternPlayers, stored under names, for use in SynthTree, selectable from SC GUI with drag-and-drop or Emacs-ido-completion.

Maybe Templates should be taggable!

So a Template class should be defined, to hold the tags along with the template.

See =Templates/AboutTemplates.org=.

Testing synthdefs chucked into SynthTrees:

#+BEGIN_EXAMPLE
d = SynthDef("asdf", { WhiteNoise.ar.adsrOut }).add;
d => \test;
#+END_EXAMPLE


** push params in currentEnvir



** fix drag start from fader DragBoth.  SynthTree:asString -> Function does not understand "name"!

** creating a new SynthTree which contains an input should make that SynthTree the current selection, so that typing control-return on a SynthTemplate selection sends it to the latest created SynthTree with input.

** Group of global keyboard commands based on H-c and H-c H-x.
Also improve the keyboard command documentation, showing the rationale for the commands:

- Basic combination 1: C-M key
- Basic combination 2: H-c key or H-c H-key
- Basic combiantion 3: H-c H-x key or H-c H-x H-key

** Push synth+parameters onto currentEnvironment
:PROPERTIES:
:DATE:     <2014-03-31 Mon 12:06>
:END:

- Chucking something into a SynthTree always makes this the selected SynthTree - on which further actions from gui or code apply.
- The selected SynthTree makes its parameter (SynthArgs) environment be the current environment, so that one can chuck stuff to the parameters through the environment!
** Make patterns restart on SynthTree.init and continue on synth chuck
(Sun, Mar 30 2014, 19:55 EEST)

#+BEGIN_EXAMPLE
{ SinOsc.ar(\freq.kr(400)) } => \sound;
// Play a pattern into ~freq:
{ 50.rrand(80).midicps }.pp(0.1) => ~freq;
// Pattern should keep playing:
{ LFPulse.ar(\freq.kr(400)) } => \sound;
// Pattern restarts when the synth starts, even after thisProcess.stop;
thisProcess.stop; // stop routines and synths
// Pattern should also restart now:
SynthTree.init;
#+END_EXAMPLE



** SynthTree: review root scheme to use envir


Insert 2 envir variables, separate for each server parent envir:
~root = the root of the server tree
~dur = the default duration for playing patterns.  Can be a stream, or even responder ... (!)

** Faders: Free, Indicate released status of synths

When fadeout is long, one may think that it is not working.  Change color of fader to indicate that fadeout has started.

** Fix mixup when restart/free during fadeout
:PROPERTIES:
:DATE:     <2014-03-31 Mon 12:24>
:END:

** Add fade-in and fade-out toggles for both selected node and entire SynthTree, with times from 0 to 9 seconds, bound to the corresponding keys from 0 to 9.

** SynthPattern draft 1 done
:PROPERTIES:
:DATE:     <2014-04-02 Wed 11:14>
:END:
(Note to self: Forget about nesting here.  For that you need EventList.)

The valueStream may produce as value an array of 3 elements:

  1. Name of synthdef to play, or nil for silence.
  2. Args array for the synth, eg: [\freq, 440, \amp, 0.1 ... etc]. The SynthTree adds the target group, addAction, and output/input parameters to create the synth.
  3. Duration after which the SynthTree should release the synth.  The SynthTree schedules a function roughly like this:

: SystemClock.sched(dur, { synth.release })

or:

: aTempoClock.sched(dur, { synth.release })

Dur may be different from the delta time for the next event of the pattern, depending on legato.

Following this through the three stages patern -> stream -> next value:

Pattern should contain:
- instrumentpattern
- parampattern
- legatopattern

These three are converted to streams and put into a SynthStream, which creates SynthEvents to play.  So we have following classes:

1. SynthPattern - contains the pattern producing the stream
2. SynthStream - contains the stream producing the event
3. SynthEvent - contains the parameters for creating the Synth

We can make these work with PatternPlayer.

** Fix H-M-p and H-p going backwards for org-mode

*** ! Mix (SinOsc.ar(LFNoise0.kr (15).range (70, 90).midicps * [1, 3, 5], 0, 0.2 / (1..3)) )
*** 1, 3, 5, 7
Mix (SinOsc.ar(LFNoise0.kr (11).range (50, 70).midicps * [1, 3, 5, 7], 0, 0.2 / (1..4)) )
*** Lower 1, 3, 5, 7
Mix (SinOsc.ar(LFNoise0.kr (12).range (30, 50).midicps * [1, 3, 5, 7], 0, 0.2 / (1..4)) )

** Extend PatternPlayer to play SynthTrees
:PROPERTIES:
:DATE:     <2014-04-02 Wed 11:16>
:END:

- Remove instrument from SynthPattern / SynthStream / SynthEvent. The instrument should be provided by the PatternFunc that plays the SynthEvent.

- fadeTime should not be given as adverb of =>.  Instead use adverb of => to specify numChan.

- add numChan as parent environment variable for SynthTree


** Check H-C-n/p

They do not immediately evaluate the chosen snippet, but work like H-p/n

Test here:

*** ! { WhiteNoise.ar } => \test

*** ! { GrayNoise.ar } => \test


** Playing patterns in SynthTree

Steps:

1. Try getting values from stream in MultiControl
2. Try timing the triggering of new synths in SynthTree with a routine
3. Try PatternFunc for control of single parameters
4. Define class SynthTreePlayer that acts similarly to Pbind, but plays a SynthTree.



** DONE Fix sending pattern synthrees to different inputs
CLOSED: [2014-04-06 Sun 21:07]

When sending a SynthTree sending a pattern to one lpf synthree, and then switching to another, hpf, SynthTree, the sound stops.  Why?

Done: PatternSynth should move only its Group, not itself as synth.

** DONE SynthTree.initTree loses Patterns in FX
CLOSED: [2014-04-07 Mon 11:03]

A pattern that outputs in an effect is not put back into that effect on SynthTree.initTree after stopping all synths.

Fixed: Supplied output bus to PatternSynth in method PatternInstrument:asSynth.

** DONE Synth timing / chaining?
CLOSED: [2014-04-07 Mon 11:06]

Implemented as a variant of this draft:

Play a synth for a given duration:

{ } => number => symbol (synthDef)

or

{ } dur: number => symbol (synthdef)

Number: receiveChuck ->

- Make routine for starting / stopping
- add SynthTree as notifier to stop if SynthTree is released/faded out/freed.

** Fix chaining with symbols, refs in patterns

Check these, and their further combinations:
#+BEGIN_EXAMPLE

[freq: { 40 rrand: 250 }.pfunc, amp: 0.2] =>.i \lpfpulse => 0.5 => \test;

[freq: { 40 rrand: 250 }.pfunc, amp: 0.2] => 0.5 =>.i \lpfpulse => \test;

\sine => \test;

`\sine => \test;

#+END_EXAMPLE

** Review binary operators

*** [Implementing:] Alternative 2: with *>

Overview / list of operators in alternative 2:

1. => chuck things to SynthTrees, create or modify PatternPlayers, PatternInstruments.
2. -> associate patterns to parameters.
3. *> chuck something to a parameter of a SynthTree.
4. =< send output of a synth to the input of another synth.
5. @> map parameter of SynthTree to bus

Details:

**** value -> parameter chucking to single parameters/aspects of named SynthTree

[100, 200].pseq -> \freq => \SynthTree1

[100, 200].pseq -> \dur => \SynthTree1

**** *> chucking to single parameters/aspects of current SynthTree
*> is for chucking to single parameters or special aspects duration, legato, instrument of the current SynthTree.

Examples:

500 *> \freq;
[500, 600].pseq *> \freq;
[0.1, 0.2].pseq *> `\freq;
0.5 *> \leg;
0.1 *> \dur;
\sine *> \instr;

- anything *> symbol :: chuck to parameter of current synth.  Special parameters:
  - duration :: duration of PatternInstrument
  - dur :: synonym of dur
  - legato :: legato (not a parameter of the PatternPlayer)
  - leg :: synonym of legato
  - instrument :: Instrument (of PatternInstrument)
  - instr :: synonym of Instrument

- anything *> `paramname :: chuck to duration of PatternPlayer of parameter `paramname.

**** anything => [not symbol, not ref]: make PatternPlayer
- anything => [not symbol, not ref] :: make/set duration of PatternPlayer

Examples:


**** anything => ref : make / set instrument of PatternInstrument
- anything => ref :: make / set instrument of PatternInstrument
**** anything => Symbol: Chuck to Symbol as SyntThree
**** anything => SynthTree:  Chuck to SynthThree

*** [Rejected:] Alternative 1 (without *>)

- pattern => symbol :: play pattern in parameter named by symbol, in current SynthTree ~st.
- pattern => number :: PatternPlayer(pattern, number).  Number is duration
- pattern => pattern2 :: PatternPlayer(pattern, pattern).  Pattern2 is duration
- pattern => `symbol / `pattern :: PatternInstrument(PatternPlayer(pattern), symbol/pattern).  symbol/pattern is instrument
- THIS MAY NOT BE NEEDED: pattern =>.i (|>) pattern2 or => `pattern :: PatternInstrument(PatternPlayer(pattern), pattern2).  Pattern2 is instrument
- pattern =>.d (*>) symbol / SynthTree ::  (Synonym:) Pattern is duration pattern for SynthTree's PatternInstrument
- pattern =>.l (**>) symbol SynthTree ::  Pattern is legato pattern for SynthTree's PatternInstrument
- pattern =>.i (|>) symbol / SynthTree ::  Pattern is instrument pattern for SynthTree's PatternInstrument
- pattern => SynthTree ::  Pattern is duration pattern for SynthTree's PatternInstrument
- pattern => environment var ::

- association => number :: ...
- association :: pattern :: ...
- association :: symbol :: ...
- association :: `symbol

- number => environment var :: ...
- number => symbol :: ...
- ???? number => pattern :: ?????
- number => SynthTree :: ...
*** Implementing alternative 2
:PROPERTIES:
:DATE:     <2014-04-11 Fri 15:31>
:END:
**** Implementing =>



**** Implementing *>

***** object *> symbol:

~st.chuckToParameter(symbol, object);

***** object *> `symbolRef

~st.chuckToParameterDur(symbol, object)

**** Implementing ->



**** Implementing =<



** PatternInstrument plays event, custom action
:PROPERTIES:
:DATE:     <2014-04-14 Mon 21:59>
:END:

** Mdef: Named PatternPlayer Model
:PROPERTIES:
:DATE:     <2014-04-16 Wed 04:58>
:END:

To consider:
Mdef subclass of PatternPlayer?

Maybe try first with Ndef as independent class, containing a PatternPlayer or subclass as instance var player.

This could be a practical coding pattern, and is compatible with the details of the following sections:

: \pattern1 => [instrument: \bass] => \synthtree1;

Alternative to:

: Mdef(\pattern1, [instrument: \bass]) => \synthtree1;

Alternatively this plays with a PatternPlayer, not an Mdef:
: [instrument: \bass] => \synthtree1;

The advantage of Mdef over PatternPlayer is that it is accessible through its name for further modifications, and that it can be cloned to other Mdefs which then inherit its contents but also subsequent changes.

The ability to filter the event data broadcast by a PatternPlayer is implemented in PatternInstrument, and is available both to PatternPlayer and its subclass Mdef.

*** How Mdef clone inherits

Care must be taken not to overwrite the params that are set for the clone when the params of the prototype change.

Therefore, Mdef should have separate vars for the data from the parent Mdef, and for its own data. So it is something like:

var <parent;
var <valuePattern; // this is the currently existing variable, remains unchanged.

There is no need to store the full merged *pattern* array of the prototype with the parent *patterns*.   We only need the valueStream to be merged, since this is used to produce the event for playing.  So when a cloned Mdef receives a notification from the parnent Mdef, it goes something like this:

#+BEGIN_EXAMPLE
var keys;
keys = valuePattern.clump(2).flop[0];
parent.valuePattern keysValuesDo: { | param, pattern |
    if (keys.inclueds(param).not) { ... add only those to stream }
};
valuePattern keysValuesDo: { | param, pattern |
    ... add all params of self to own stream
}
#+END_EXAMPLE



*** Creating, chucking to synthtree

#+BEGIN_EXAMPLE
Mdef(\p1).play;  // create PatternInstrument named p1, play
\p1 => \synthtree1; // send it to \synthtree
#+END_EXAMPLE

This is no longer possible:
\instrument => \synthtree;

But this will serve as substitute:

`\instrument => \synthtree;

More examples:

Mdef(\p1, [degree: 5]); // Always (re-) initializes contents!

To not clear, but merge contents:

Mdef(\p1) set: [amp: { 0.01 rrand: 0.1 }.pfunc];

*** Modifying an Mdef: alternative shortcut =>

Mdef(\p1) set: [degree: (1..3).pseq];

or alternative shortcut:

\p1 => [degree: [1, 2, 3].pseq];

*** Modifying the received event:

**** Rejected first tries
#+BEGIN_EXAMPLE
// here we have a problem: how to indicate getting the degree:
[degree: [1, 2].pseq + ~degree] %> \synthree3;
// maybe it has to be:
{ [degree: [1, 2].pseq + ~degree] } %> \synthree3;
// or use a new type of pattern to access parent:
[degree: [1, 2].pseq + \degree.parent] %> \synthree3;
#+END_EXAMPLE

**** Solution

#+BEGIN_EXAMPLE
// alternative method name: pget
[degree: [1, 2].pseq + \degree.pget] %> \synthree3;
#+END_EXAMPLE

: \degree.pget

would translate to:

: Pfunc({ ~degree })

and that would be evaluated in the parent environment using =use:=.

#+BEGIN_EXAMPLE
parentEnvir use: {
   params keysValuesDo: { | param, stream |
      childEnvir[param] = stream.next;
   }
};
#+END_EXAMPLE

*** Cloning an Mdef (quasi Pbindf)

#+BEGIN_EXAMPLE
Mdef(\p1, [degree: [1, 2, 3].pseq]) => \player1;
Mdef(\p2).clone(\p1, [dur: 0.1]) => \player2;
#+END_EXAMPLE

Then to add further filters to a player:

#+BEGIN_EXAMPLE
[degree: 3 + \degree.pget] %> \player1;
#+END_EXAMPLE

** Fix PatternInstrument to inherit global ~fadeTime.
:PROPERTIES:
:DATE:     <2014-04-18 Fri 16:24>
:END:

** New operator =!> clear synthtree before chucking new pattern
:PROPERTIES:
:DATE:     <2014-04-18 Fri 10:46>
:END:

** EventPattern: embeddable pattern player
:PROPERTIES:
:DATE:     <2014-04-21 Mon 17:55>
:END:
Mdef/PatternPlayer/PatternEventPlayer should be able to embed themselves in patterns like Pdef does:

(From the Pdef help entry:)

#+BEGIN_EXAMPLE
x = Pseq([Pdef(\a), Pdef(\b), Pdef(\c)], inf).play;

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3])));
Pdef(\b, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[7, 8, 7, 8])));
Pdef(\c, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 1, 2], 2)));
#+END_EXAMPLE

*** embedInStream mechanism


Look at following methods in Pattern:

#+BEGIN_EXAMPLE
play { arg clock, protoEvent, quant;
		^this.asEventStreamPlayer(protoEvent).play(clock, false, quant)
	}

	asStream { ^Routine({ arg inval; this.embedInStream(inval) }) }
	iter { ^this.asStream }

	asEventStreamPlayer { arg protoEvent;
		^EventStreamPlayer(this.asStream, protoEvent);
	}
	embedInStream { arg inval;
		^this.asStream.embedInStream(inval);
	}
#+END_EXAMPLE

And in Stream:

#+BEGIN_EXAMPLE
	embedInStream { arg inval;
		var outval;
		while {
			outval = this.value(inval);
			outval.notNil
		}{
			inval = outval.yield;
		};
		^inval
	}

	asEventStreamPlayer { arg protoEvent;
		^EventStreamPlayer(this, protoEvent);
	}

	play { arg clock, quant;
		clock = clock ? TempoClock.default;
		clock.play(this, quant.asQuant);
	}
#+END_EXAMPLE

And in EventStreamPlayer:

#+BEGIN_EXAMPLE
	play { arg argClock, doReset = (false), quant;
		if (stream.notNil, { "already playing".postln; ^this });
		if (doReset, { this.reset });
		clock = argClock ? clock ? TempoClock.default;
		streamHasEnded = false;
		stream = originalStream;
		isWaiting = true;	// make sure that accidental play/stop/play sequences
						// don't cause memory leaks
		era = CmdPeriod.era;
		quant = quant.asQuant;
		event = event.synchWithQuant(quant);

		clock.play({
			if(isWaiting and: { nextBeat.isNil }) {
				clock.sched(0, this );
				isWaiting = false;
				this.changed(\playing)
			};
			nil
		}, quant);
		this.changed(\userPlayed);
		^this
	}
#+END_EXAMPLE

And also in EventStreamPlayer this:

#+BEGIN_EXAMPLE
	prNext { arg inTime;
		var nextTime;
		var outEvent = stream.next(event.copy);
		if (outEvent.isNil) {
			streamHasEnded = stream.notNil;
			cleanup.clear;
			this.removedFromScheduler;
			^nil
		}{
			nextTime = outEvent.playAndDelta(cleanup, muteCount > 0);
			if (nextTime.isNil) { this.removedFromScheduler; ^nil };
			nextBeat = inTime + nextTime;	// inval is current logical beat
			^nextTime
		};
	}
#+END_EXAMPLE

*** Comments / Hints

The stream must return the event to play with next

role of embedInStream not clear yet.

*** First implementation proto-draft

See class EventPattern, EventStream.

** Use embed in stream to chain (=embed) PatternPlayers?
:PROPERTIES:
:DATE:     <2014-04-20 Sun 18:32>
:END:

Embedding of event-patterns done.  See EventPattern, EventStream.
For playing in SynthTree see Edef, Idef, Bdef.


** New README opening examples, starting with Edef.
:PROPERTIES:
:DATE:     <2014-04-22 Tue 15:26>
:END:

See file EdefTests.scd
** Designing Edef, Cdef, Idef, Bdef
:PROPERTIES:
:DATE:     <2014-04-22 Tue 15:26>
:END:

Edef: Associate an EventPattern with a symbol and implement propagation
of later modifications of the pattern to streams played from it.

IZ Tue, Apr 22 2014, 00:42 EEST

*** Making Edef, Idef, Bdef play
:PROPERTIES:
:DATE:     <2014-04-23 Wed 16:50>
:END:

Try making Edef subclass of EventPattern and Idef subclass of EventStream.  The reason is to implement the alternative asStream and embedInStream methods without having to add exra wrappers in a different class to handle them.

*** Operators:
:PROPERTIES:
:DATE:     <2014-04-23 Wed 16:49>
:END:

Note: here \edef and \synthree are example names.  Any symbol can be used instead to name an Edef or SynthTree.

**** Creating and modifying Edefs

Note: "propagate" means to send the changed contents of the edef to all of its "children".  Children are Cdefs cloned from the Edef or Idefs, Bdefs (EventPattern players) spawned from them.  The

\edef =< event; // add event contents and propagate
\edef =!< event; // replace event contents and propagate
\edef =<| event; // create/add event contents to edef, do not propagate
\edef =!<| event; // create/ replace old event contents by new event, do not propagate

\edef =>> \cdef; // clone edef into cdef.  cdef inherits future changes from edef.

If a function instead of an event is passed as second argument in the above,
then the function is evaluated with ~pattern as environment variable, and the
result becomes the new pattern of the Mdef.

**** Playing edefs in SynthTrees
Furthermore, the above may be chained with a chuck to a synthtree:

Going directly to SynthTree:

\edef => \synthtree; // play a new stream into a synthtree
// Stream is named after synthtree.
// Stream replaces previous stream

Initializing or modifying contents with an event, and then chucking to SynthTree:

\edef =< event => \synthtree
\edef =!< event => \synthtree
\edef =<< event => \synthtree
\edef =!<< event => \synthtree

**** Chucking events directly into synthtrees

***** event => \synthree

Chuck event to synthree's stream and play.

Always create new unnamed Bdef.

Always cross-fade.

***** event +> \synthree

Add event contents into synthree (merge).

Playing stream's event is modified.  Modifications are inherited, and overshadow (block) future modifications inherited from changes in parent Idefs or Edefs.

The values of the chucked event are evaluated in the environment of the stream's event, which means that they can be functions which access the entire event as environment.

Also accepted:

{ function } +> \synthtree

Produce new stream from existing stream and substitute new stream in the stream player.

Playing stream's event is modified

***** event +!> \synthtree

Replace event contents of synthtree's stream.  Like +>, except that the contents of the event of the playing stream are fully removed before adding the contents of the new event.

***** event %> \synthtree

Add "mod" filter - without altering contents of event stream.

A mod filter is an event contained in instance variable =mods= of BdefInstrument and whose key-value pairs are always added to each event produced by the playing stream.

This is for playing multiple synthrees with one stream, while varying the way of playing on a synthree basis.

Each key - value pair of the chucked event overrides previous values in the event produced by the playing stream.

The values of the chucked event are evaluated in the environment of the stream's event, which means that they can be functions which access the entire event as environment.

The stream's event is not modified.  These changes are strictly local to the playing SynthTree.

Durations of the stream cannot be modified by %>.

// Maybe this not!: { function } %> \synthree
// Perhaps later.

***** event %!> synthtree

Replace current "mod" filter by the chucked event.  See %> for explanation of mod.

**** Named spawned stream players (Idefs)

Using symbols references to explicitly name spawned streams

***** Creating Idefs

\edef => `istream // create Idef named `istream from edef.

***** Creating Bdefs

Association is used to defer the creation of the Bdef until it is chucked to a synthtsream.  Otherwise it would become an Idef.

\edef -> `stream => \synthree // play named stream as Bdef into synthree

***** Modifying Idefs or Bdefs

event => `estream // modify estream Idef or Bdef
{ function } => `estream // modify estream


***** NameSpace

Use generator class NameSpace for named instances, instead of subclassing.

***** Modifying the eventstream or pattern with "mods"

A mod takes the event inherited from the parent and applies modifications to it in order to generate a modified Event that is used by the EventPattern or EventStream.

Analysis of mod possibilities

Possibilities 1 - 2 can coexist in any combination.
Possibilities 3 and 4 are exclusive of any other possibility.

1a. Replace a param pattern of the parent by a different pattern (possibly remove)
1b. Replace a param pattern of the parent by a pattern modifying the parent pattern
2.  Add a param pattern.
3a. Replace the entire pattern of the parent by a different pattern.
3b. Replace the entire pattern of the parent by a different pattern derived from the parent.
4. Replace nothing.

***** Inheriting process

Inheriting takes the event (pattern?) from the parent and combines it with
the mods to produce the pattern that will be used by the Edef/Idef that uses it.
It also propagates the resulting event to all inheritors.

***** How mods are modified

The mod stores the modifications to be applied for obtaining the current players event from the parent.  But when we add a modification, we change the mod itself.  In principle there are many possibilities to change a mod:

1. Replace the mod entirely
2. Remove the mod entirely
3. Remove part of the mod
4. Replace part of the mod
5. Add a new item to the mod
6. Modify an item of the mod

For the sake of simplicity, the present implementation will only handle two cases:

1. add: add the new items to the mod, replacing any items of the same name.
2. addClear: Remove all previous items of the mod, and then add the new ones.

Other operations may be added later as needed.

** Make Edef and SynthTree play with EventPattern instead of PatternEventPlayer.

Note: All inheritance/modifications should be done with Edef, its related classes Cdef (inheriting clone of Edef), Idef (inheriting named wrapper around EventStreamPlayer), Bdef (subclass of Istream that makes the streamplayer broadcast instead of playing) or SynthTree.  Keep EventPattern, EventStream as simple as possible.

*** Next things in this matter
:PROPERTIES:
:DATE:     <2014-04-21 Mon 18:47>
:END:

Wed, Apr 23 2014, 16:23 EEST: The following have been implemented by Idef, Bdef.

Possible candidate to play inside SynthTree as template?

Or a variant of PatternInstrument that listens to updates from Mdef, coupled with a different kind of Event that broadcasts itself on "play" instead of playing?  The advantage is that the PatternInstrument can then apply "filters" on the incoming event to permit playing the same event stream in different ways.

The broadcasting technique has the advantage that one can attach additional behaviors such as monitoring, sending as osc or midi, updating views etc.  to the playing event stream easily.

Furthermore, since we can nest EventPatterns, we will also want to nest Mdefs.  So an Mdef cannot be the one who plays a stream, because multiple streams may be spawned from it.  So the playing should be done exclusively inside SynthTree (also for simplicity's sake).  So the template var inside the SynthTree that is playing the event stream spawned from an Mdef is something else than an Mdef.  It looks as if it could be a variant of the current PatternInstrument with a new implementation as far as Pattern playing is concerned.

The new PatternInstrument should have:

- The Mdef it was created from (to respawn).
- The EventStreamPlayer that it is playing (so that it can start it or stop it).
- Any other synth/group/bus/SynthTree related stuff (derived from as it is now).
- The facilities for varying the way that the received events are played ("filter").

**** QUOTE How to do the broadcasting

Use a subclass of EventStreamPlayer, called EventStreamBroadcaster that uses a variant of prPlay as follows:

#+BEGIN_EXAMPLE
prNext { arg inTime;
	var nextTime;
	var outEvent = stream.next(event.copy);
	if (outEvent.isNil) {
		streamHasEnded = stream.notNil;
		cleanup.clear;
		this.removedFromScheduler;
		^nil
	}{
// Instead of playAndDelta, use broadcastAndDelta.
		nextTime = outEvent.broadcastAndDelta(cleanup, muteCount > 0, this);
		if (nextTime.isNil) { this.removedFromScheduler; ^nil };
		nextBeat = inTime + nextTime;	// inval is current logical beat
		^nextTime
	};
}
#+END_EXAMPLE

And in Event, add =broadcastAndDelta=, keeping all code, and changing only the line =this.play= to streamPlayer.changed(this), so that receivers may optionally play a modified version of the event, or otherwise react in different ways.

#+BEGIN_EXAMPLE
broadcastAndDelta { | cleanup, mute, streamPlayer |
	if (mute) { this.put(\type, \rest) };
	cleanup.update(this);
	// this.play;  // instead of this, use "changed".
        // instead of playing, broadcast, with "changed":
        streamPlayer.changed(\event, this);
	^this.delta;
}
#+END_EXAMPLE

**** Runtime modifications apply to EventStreamBroadcasters, not Mdefs (!?)


**** Coding examples

Playing an Mdef: Always creates a Bdef.

#+BEGIN_EXAMPLE
Mdef(\x).play; // plays into EventStreamBroadcaster (Bdef) of same name
Mdef(\x).play(\y) // plays into EventStreamBroadcaster named \y

// Possible shortcut:
\x => `\y;
#+END_EXAMPLE

Play into Bdef(\x) and chuck into \player1 SynthTree

#+BEGIN_EXAMPLE
Mdef(\x) => \player1;
// Equivalent to:
Mdef(\x).play => \player1;
// Possible shortcut:
\x => \player1;
#+END_EXAMPLE

Play Bdef(\y) into \player2 SynthTree
#+BEGIN_EXAMPLE
Bdef(\y) => \player2;
// Possible shortcut:
`y => \player2;
#+END_EXAMPLE

* Undergoing tests

** =SynthTree=: Storing/interconnecting Synths

ChucK-style operators: =>, variants: =<>, ==>, =<, =^.

** =Pub= (previously defined as =Source=) Flexibly connect objects to data sources

Publish data received from a source (PatternPlayer, OSCFunc, MIDIFunc, GUI) to any object that is concerned. Able to:
- Replace the origin of the data source at any time.
- Work interchangeably with Patterns/Streams, Views, OSCFuncs, MIDIFuncs, constant values.
- Customize, map and/or filter the messages and values sent to listening objects.

Note: Previously (Wed, Mar  5 2014, 17:08 EET) this class was called =Source=.  But this created confusion, because the Source actually publishes to many objects the results of polling another object, which is the stream *source*.  So it would be better to call this class "Publisher", or for short: "Pub".

*** Basic method: =pub= (previously =src=)

: anObject.pub(source, mapper);

Get or create a Source instance, and connect its output to anObject.  Return the Source instance.  The way in which the output is connected to the receiving object is set by the mapper, which encapsulates both any processing of the value received such as mapping it with a spec, and the message to be sent to the receiver, such as =.set(\freq, mappedValue)=.  For example:

: anObject.pub(source, [500, 600].mapSet(\freq));

The above makes the object =source= send to =anObject= (usually a Synth instance), the message =set= for setting parameter =freq= with a value mapped from an input in the range of 0-1 to the range of 500-600.  The source can be any object that generates values in time, for example a Task (Routine not supported yet), an OSCFunc, a MIDIFunc, a gui Slider, etc.  The object given to method =pub= as its =source= parameter can be either a symbol for accessing an already existing Source instance from a global dictionary, or a template that is used by Source to create a Source instance which will broadcast the generated values.

Here are the steps of this mechanism:

1. Find or create the source instance.
   - If =source= is a symbol, then get the source instance from the dictionary in Source.all.  If no instance is found under the given symbol, then create one.
   - If =source= is an instance of Source, proceed to the next step, connecting =source= to =anObject=.
   - Otherwise create an instance of source using the object as source of values.  The object given in =source= is treated differently according to its kind:
     - pattern: create a Stream from pattern.
     - view: set the action of the view to do source.changed(... view.value).
     - OSCFunc: set func of OSCFunc to do source.changed(...).
     - MIDIFunc: set func of MIDIFunc to do source.changed(...).
     - SequenceableCollection: Pseq(collection, inf).asStream, polled at intervals given by Source.pollRate.
     - Any other object: return routine polling the object with object.value(source)
       and broadcasting the resulting value to the listeners of the source.  This also works for Functions.  Use classvar pollRate of Source as polling rate.

*** Shortcut: set parameter of Node from values (NOT YET IMPLEMENTED)
 A special case/shortcut method for setting the parameter of a Node (Synth or Group):
: aNode.rset(routname[->parname], valueStream, timeStream);

- =parameter/controller= :: A symbol or an association parameter->controller. =parameter= is the name of the parameter of the synth to be set by the routine. =controller= is the symbol under which the routine is stored. If no controller name is given, then the controller name defaults to the parameter name.
- =valueStream= :: Any object.  Values are obtained from the stream by sending it the message next.  Patterns are converted to streams with asStream before being used.
- =timeStream= :: Any object that returns a stream of positive integers (duration values) when sent the message next. (Similar to valueStream).

*** first prototype - polling streams with a routine and timing
The routine is created rougly like this:

{
	var val, dur;
	while { (val = valStream.next).notNil and: { (dur = durStream.next).notNil } }
	{
		thisThread.changed(\value, val, dur);
		dur.wait;
	};
	this.changed(\p_end);
}

The controlled Synth may choose to =free= or =release= itself when receiving =\p_end= at the end of the routine process.

*** Details: encapsulating routines and other data sources

Source Encapsulates the routine in another object that sends the notifications, so that one may substitute a new routine in that object and still keep the connections to all listeners controlled by the object.  It can hold any object that wants to broadcast a stream of values, such as a poller of audio or control stream values, a tcp poller, an osc or midi event listener, a gui widget event listerer etc.  Finally, the listening objects receiving notifications from the Source instance can use adapters to react differently to the data received.

** =MapFunc= Encapsulate mapping action and sending message to listener

Encapsulate the spec in the mapping function, thereby saving the trouble to store specs in an extra variable.  Also exchange mapping or other type of response functions at any moment, without having to store these actions anywhere.  Use =Object:removeNotifier(notifier, message)= to remove the previous instance of the notification and replace it with the new one.

Variables of MapFunc:

- source :: object that sends the values
- listener :: object that receives the message and converted value from the update.
- mapper :: function or other object that processes the values received from the source and sends them to the listener as a message (=listener.perform(*args)=). Other types of responses to =value= are implemented by specialized subclasses of =MapFunc=.

The three items above can be useful to the =MapFunc= as sources of further information or targets of further actions when performing its action.  Therefore the action is passed the MapFunc instance along with the value, so that it may retrieve further info from the listener or notifier, or perform other actions on them or remove itself etc.

- action :: function that maps or otherwise acts on the value received from the update.  Note: A spec does not need to be stored separately, because it can be made available to the function through a closure created by another function that creates the action function.  The action returns an array whose first element is the message to be performed by the listener and the rest of the elements are arguments to that message.

*** Connecting an object to an updater (Pub)
NO LONGER VALID!:
Message for connecting an object to an updater (Pub) - yet see next subsection below!

: specF(action)

Action can be constructed by messages to Arrays, Functions, or other types of objects.
For example =\freq.asSpec.setter(\freq)= would return a function that returns an array:
=[\set, \freq, mappedValue]=.  Or this could be further abridged to: =\freq.mapper= where the name of the parameter to be set defaults to the receiver.

Here is maybe a better version:

*** Shortcuts for connecting an object to a Pub:

Use standard prefix v (variable) or s (source) for the method names.  For example:

=vmap= is for variable map, where map is from the map operation in Lisp, which operates on each value of a collection (in this case, the stream of incoming values).

=vmap= is sent to a Symbol.  It creates a MapFunc instance, named after the symbol, without an action.  The action can then be set by sending the instance messages. Such messages are described in the next section:

*** Shortcuts for creating mapping functions

- =map= :: Create a function that sends the listener the message set thus: =listener.set(parameter, mappedValue)=.  The parameter can be provided as argument.  The spec for mapping the input value is also created from data passed as argument.
- =unmap= :: Like map, except that the spec is used to unmap instead of to map.
- =bimap= :: Like above, except it uses a custom class =BiMap= (see Lilt2 library) to map from aaaaany custom range to any other custom range.
- =args= :: evaluate each of the args passed to this function each time with the value received, collect the resulting array, and send it as message to the listener thus: =listener.perform(*args);
- =select= :: only send message with (mapped?) value when the value satisfies a condition.
- =reject= :: only send message with (mapped?) value when the value does not satisfy a condition.

Here some earlier drafts with details - not entirely consistent with the above.

Examples:

=set= creates a function that sends the set message with the value mapped through a spec produced from a specPrototype, guesses the parameter name from the prototype, or gets it from paramName, and optionally inserts restargs between the parameter name and the mapped value.

: listener.vmap(source).2qset(specPrototype, (optional:) paramName ... restargs)

#+BEGIN_EXAMPLE
// listener.vmap(source) does the following:
var mapFunc;
mapFunc = MapFunc(listener, source);
listener.addNotifier(source, \value, mapFunc);
^mapFunc;
#+END_EXAMPLE

The returned mapFunc is used to construct the action by sending it

Most general case: collect the result of evaluating each of the args with the value as argument, and send it to the listener with listener.perform(*args). Thus, even the message sent can vary according to the input.  We may use a special message =null= defined for Object, to send any object messages that should be ignored (null method).

: vmap(source).send(... args);

For example:

: aSynth.vset(aStreamPub).spec(\freq);
: aSynth.vset(aStreamPub).spec([10, 100],

Seletive action constructors could be defined:

: vselect(source).select()
: vreject(source).reject()

** PatternPlayer: Play a pattern, as stream, getting durations from another pattern

The timing of successive value requests from the stream is defined by another stream,
that produces the dt (time intervals) to wait for the next call of "next".

Patterns of both values and durations stream can be exchanged on-the-fly while the player is running.

Used by Pub as default source for all objects except OSCFunc, MIDIFunc and View.

* Next plans:

** Playing patterns in a SynthTree

*** Idea 1: args envir w. StreamPatterns

Store args for synth in an Event, in args variable.  These can be used to start synth.

But they could also store streams.  In this case, each time the synth starts, it starts with the next set of values from the arg event's streams.  Then the template could also be a stream possibly returning different instruments at each call of next.

In order to be able to reset the streams from the patterns, store each stream together with its pattern in a new Class: StreamPattern.

Each StreamPattern can play with its own Task (see PatternPlayer).  The latest value produced by =next= on the stream is stored in var =next=, so that it can be accessed each time that a synth is created, without asking the stream itself to produce a next value.  When asked next, the StreamPattern decides whether to use the already produced next (if its Task is running), or to return the next value in the stream (if no Task is running).

Or they could be busses instead - in which case they map the synths arguments.

They could also be substituted by or combined (BinOp) with controllers (GUI, MIDI, OSC, other), received via =Pub= updates.  Similarly, they could be linked to updates issued by streams in other synths or global shared Pub updates.

*** Idea 2: =SynthStream=: Alternative to Pbind
 Pluggable inside a SynthTree instead of a Synth.

 Allows exchange of data-streams for parameters on-the fly (JitLib style, but without the busses and possibly simpler). SynthStream should be visible to the SynthTree like a Synth (interface-wise).  It could be a subclass or variant of PatternPlayer.  Its valueStream would be an environment (or even event) from which the arguments of the next synth are collected.  Fade-in and -out can be implemented by hijacking the ~amp stream, and setting it to poll a control-rate env or line synth on bus private to the stream.  Optionally, additionally, at the same time mapping the amp of each synth, after creating it, to the same amp bus.

** CBoard

Add/remove widgets dynamically in a single gui window, for display and control of processes.  The window can be placed at one of the 4 sides of the screen.  Show just the widget with a label.  Default widget: Knob (for compactness).  More functionality accessible by typing keyboard commands at a selected window (possibly with ctl key):  Start/Stop the related process, input a new source-template for the process, etc.

Each window stores the widgets in a dictionary under the names of the labels, for access.

*** Interleaved control from multiple sources on one Pub

** SourceTree: Edit trees of sclang processes
See:
file::./classes/ProcessComposition/ProcessCompositionNotes.org

SourceTree: Language and representation of trees of event sources (Patterns/Streams, OSCFuncs, MIDIFuncs etc) composed with operators to Pbinop and BinaryOpStream.

Add, remove, replace any element of the tree by giving its address as a symbol composed of =l= and =r= for specifying the movement down the branches of the binary tree.

* Started, but currently on hold

** MixBus class

This idea may be implemented better as an extension of the NodeTree idea.

Subclass of Bus.

MixBus(name, numChans, out); // create new instance if needed, and make it current.

Alternative for above:
\name.mixBus(numChans, out);

Also creates its own Group.
When created:

- registers itself in MixBus.all class variable under its given name (symbol), for access.
- sets the following current environemnt variables:
  - ~out :: index of the bus. Synths can write to this bus.
  - ~target :: its group
- Creates synth called =gain= positioned after =~target=, providing:
  - global level control (control name: =gain=)
  - adsr envelope for fadeout with method =release(releaseTime)=
- The =gain= synth directs its output to another channel, per default channel 0.
- Different types of =gain= synths can be used, to provide effects and multichannel output
- Other synths can be added before =gain= to provide additional effects.
- Syn(...) reads ~out an ~target from the environment, and therefore by default uses the installed MixBus, if present.
- Define keyboard shortcuts in SC for altering the level control of the current mixbus (the one belonging to the current environment).
- Create GUI for MixBus.  The gui can show all mixbusses stored in MixBus.all.
- The =gain= synth can be released to shut output of a mixbus.  A new gain synth can be created at any moment to restart output, or even to crossfade a different type of output.
- To remove a mixBus entirely call mixBus.remove.  This releases the gain synth, removes the group when the gain synth is freed, removes the mixBus from the =all= variable, and frees the bus.

** More convenient ways to map Synth parameters

*** Synth:busctl : map parameter to a bus to which a synth outputs.

(note: older name of method was =nmap=).

: aSynth.busctl(busname[->parname], controlSynth)

This method maps a bus stored under a name =busname= to a input parameter (control) of the synth being controlled. =parname= is the name of the parameter to which the bus is mapped.

- =busname[->parname]= :: A symbol =busname= or an association =busname->parname=. If no =parname= is given, then =busname= is used as the name of the bus to which to map and the name of the parameter that this bus will be mapped to.  If an association =busname->parname= is given, then =busname= is the name of the bus and =parname= is the name of the parameter to which the parameter is mapped.
- =controlSynth= :: A control-rate synth to be mapped.

For example:

: { SinOsc.ar(\freq.kr(400), 0, 0.1) }.play
: .busctl(\freq, { LFNoise0.kr(5).range(400, 500).out }.play);

Outline of actions done by this method:

1. Access bus as value in a global dictionary of Synth-bus or symbol-bus associations.
2. Create new bus if not already present, and set output of controlSynth to bus index.
3. Map parameter to index of bus.

Note: bus should/may be freed and removed from global dictionary when all of its synth inputs are freed.

* Further Plans:

- Org-table as score?
- Add to sclang-snippets:
  - Each snippet eval output is stored in list of objects, in emacs buffer,
    for access, eg. to free or pause a synth, routine, group, pattern player etc.
  - If return value is synth: store synth
  - If return value is routine: create own group for putting synths in,
    so that synths are also freed when routine is stopped?
    Possible?  Only via currentEnvironment.  Use variant of Synth.new
    to access currentEnvironment's target?
    This could be method synth of string or symbol, called in similar manner as Synth.new:
    Instead of Synth("test"), write synth("test").
  - Similar to routine, also for Pbinds.
    Check if Pbind accesses currentEnvironment to get \target value.
    If so, then implementing private group per snippet should be easy.

* Implementation notes

** Stopping processes started from code contained in an org-mode section

Pass the id of the current snippet/section as environment variable by enclosing the code to be evaluated with =sc-lang-eval-string= in a function evaluated within a new environment.

#+BEGIN_SRC elisp
  (sclang-eval-string
     (concat
      "(source_id: '"
      (org-id-get-create)
      "', eval_id: UniqueID.next) use: {\n"
      string
      "\n}"
  ))
#+END_SRC

Storing the ID-process correspondences in SC: Store each process in an instance of NamedProcess, with its org-section (source) ID and eval ID (the number of times that this snippet is currently running).

The eval id is stored as property in the org-section.

** Process trees?

To kill all child-processes of a Routine one may add thisThread as notifier to a child process (Node or Routine or EventStreamPlayer) and notify the children when the thread stops.  Similarly for EventStreamPlayer.  Registering processes under a snippet/org-section id is a simpler alternative. However process-tree based stopping is a different thing, because one may want to kill a parent-process through the gui, independent fom the snippet grouping which may contain also other processes.
