* !!! REDO Bus linking using @> and buslinks bound to symbols

For audio busses:

- \bus @>.input \chuck :: Chuck reads from this bus at parameter named by adverb ('input').
- \bus <@.output \chuck :: Chuck writes to this bus at parameter named by adverb ('output').

For control busses

- \bus %>.input \chuck :: Chuck reads from this bus at parameter named by adverb ('input').
- \bus <%.output \chuck :: Chuck writes to this bus at parameter named by adverb ('output').

But you can also use shortcuts:

'source.out>bus.numchans@effect1.in>bus.numchans@effect2'.alink; // shortcut: al // = ar

'source.out>bus.numchans@effect1.in>bus.numchans@effect2'.klink; // shortcut: kl // = kr


* TODO Chuck: Store =target= in extra instance var?
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

** DONE Chuck: Rewrite scheduling using a separate class.
:LOGBOOK:
- State "DONE"       from "STARTED"    [2015-06-12 Fri 11:42] \\
  done
- State "STARTED"    from "DONE"       [2015-06-11 Thu 16:00] \\
  still working on removing old scheme, and completing filters
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done - but still working on filters
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

- Should contain a task.
- Can register under same name as Chuck, but in its own subtree.

: ^Registry(ChuckTask, chuckName, { ChuckTask(chuck, pattern) })

Advantages:

- Simplifies Chuck by removing durStream, dur
- Allows sharing of TempoClocks by stopping Task instead of TempoClock.
- Simplifies and standardizes method for generating count + pattern for matching.
- May be used for playing timing structures generated by Org-Mode tables (see PatternLang.org).

* TODO Fix rewiring of source from serial to parallel

#+BEGIN_SRC sclang
//:
Server.default.queryAllNodes;
//: linking

\a +> \b;
{ WhiteNoise.arp } ++> \a;
{ Resonz.arps(In.ar(\in.kr), LFNoise0.kr(30).range(500, 5000)) } ++> \b;
//:


//:
{ Resonz.arps(In.ar(\in.kr), LFNoise2.kr(9).range(150, 500), 5) * 2 } ++> \b;
//:
{ In.ar(\in.kr) * 5 * Decay.kr(Dust.kr(3), 2)} ++> \c;
//: TODO: Fix it so that the following sequence of switches works
\a +> \c;
//:
\b +> \c;
//:
\a +> \b;
//:

\a.toRoot;

\b.toRoot;
#+END_SRC

* TODO ChuckSynthSource+arp, perc: Use release for safer synth stopping
:PROPERTIES:
:DATE:     <2015-06-12 Fri 11:58>
:END:

* TODO Chuck: Enable functions in args for dur filtering etc
:PROPERTIES:
:DATE:     <2015-06-12 Fri 11:58>
:END:

* TODO Complete implementation of BusLink unlink method

* TODO Investigate use of ().play as play method in ChuckSource

* STARTED Investigate event sharing/filtering in Chuck (like in Tiny 0)

This is linked to using ().play as play method

Task could be generating the events to be shared. But how to access the shared data?

First steps:

- Passing task as argument to Chuck.play, and having task process Chucks args with its own data.

Next:

Design new class EventFilter that will either be a subclass of Event or contain one, and will respond to method =passArgs=

* All DONE tasks
** DONE Optimize ChuckSynthSource
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-11 Thu 15:58] \\
  Done!
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 12:51>
:END:

Extend ChuckSynthSource with new subclass ChuckFuncSynthSource to add the SynthDef of the Synth source function when a new ChuckFuncSynthSource is created, and create synths with =Synth()= instead of ={ ... }.play=.

This is easy: =Chuck:source({ ... })= (called by: ={ ... } +> \aChuck=) always creates a new ChuckSynthSource instance.

Method ChuckFuncSynthSource:new:

- Construct the name of the SynthDef like this =format("<%>", name)=.
- Immediately construct and =add= the SynthDef, using Function:asSynthDef, possibly with modification of GraphBuilder.wrapOut to add fadeTime as control instead of as one-time-only (fixed) value.
- Use modified Function:play method (possibly named =add=) to /store synth name and notify the containing chuck (!) that it has completed loading/.

Method ChuckFuncSynthSource:prPlay:

Check if synthdef name is set.
- If it is nil, add ChuckFuncSynthSource instance as listener to the containing Chuck instance on message =defloaded= and create the new synth then.
- If it is not nil, play the new synth using the stored synthdef name string.

Note: The ChuckSource class hierarchy becomes:
- ChuckSource
  - Chucksynthsource :: play strings as DefNames with Synth()
    - ChuckFuncSynthSource :: play functions by adding them as SynthDefs and storing the string to play synths as soon as the def is loaded on the server.

** DONE Chuck: Store =out=, =fadeTime= in event, not parent
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

So that they be always included in args when playing ChuckSynthSource with new methods resulting from [[*Optimize%20ChuckSynthSource][Optimize ChuckSynthSource]].

** DONE Debug Tox addition to Tox
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-15 Mon 10:17] \\
  done
- State "DELEGATED"  from "WAITING"    [2015-06-15 Mon 10:17]
:END:
:PROPERTIES:
:ID:       4606C6B7-6175-46CB-B0F7-52434245CFBA
:eval-id:  4
:END:

Possibly the *>> operators add double dependants so re-adding makes the pattern play twice.
