#+TODO: TODO STARTED | DONE CANCELED OBSOLETE REJECTED
* Underway
** STARTED ChuckPatternSource, EventPatternSynth
:PROPERTIES:
:DATE:     <2015-06-22 Mon 00:54>
:END:

Play EventPatterns in a Chuck.
*** ChuckPatternSource
Notes:

- Plays Event as EventPattern
- The Event is stored in an EventPattern.
- The EventPattern is stored in source.
- Chuck's args specify in and out bus and target.  Therefore they are copied to the event of EventPattern in source before playing.
- However, the Events generated by the EventPattern must play through a separate group, that is create inside the target group, and that serves to move those synths when the whole chuck needs to move to another group (target) because of linking I/O.  Therefore, the target of the event of the Event of the EventPattern must be replaced by that group before the EventPattern starts playing.
- The makeSynth function of ChuckEventPattern creates an EventPatternSynth, a subclass of Synth, which creates its own group inside the target group, and overloads method =moveToTail= to move its own group to the tail of the target instead of itself.  The details of EventPatternSynth are explained below.

*** EventPatternSynth
:PROPERTIES:
:DATE:     <2015-06-25 Thu 00:55>
:END:

Subclass of Synth
1. uses its own SynthDef, which copies signal from input to output wrapping it in a fade-envelope.
2. Overloads =moveToTail= so that instead of moving itself to the tail of the target, it moves the group that it is contained in to the tail of the target.  This is because it runs in a group created by EventPatternPlayer, which is used as target group for all synths created for the target.  The purpose of the group is to enable moving all synths of the pattern to a different group when the player is moved to a different part of the node tree for linking I/O.
3. on creation, does the following:
  1. Alloc new bus (happens immediately).
  2. Create group inside (tail) of target group (is asynchronous, must use onStart to start synth after it).
  3. Set the EventPattern's target to the newly created group.
  4. Create self as fade synth (asynchronous, use onStart to start pattern after it)
  5. Fade synth's doneAction frees group and all synths inside the group.
  6. Fade synths's onEnd notifies ChuckPatternSource to stop playing EventPattern.
  7. Start playing EventPattern.

Implementation notes for =new= method:

1. create own group
2. allocate bus
3. set source's eventpattern's fadeBus and target
4. then send self
5. start playing eventpattern
6. doneAction is free self, group, and synths contained in group
7. onEnd: free bus and stop EventStreamPlayer
8. set source's chuck's output to newly created instance of self.

** STARTED MiniSteno

See MiniSteno.sc, MiniSteno class.

Thoughts for further refinement:

- use "astring".asteno for audio config and "astring".ksteno for control config
- Do not use { } @>.param \chuck, because of the problem of naming the created k-chucks.  Stick with ksteno.  Perhaps use: { } @> \kchuck @>.param \achuck or:
  { } @>.param_k \achuck where k is the name of the kchuck.  The name of the chuck is _after_ the name of the parameter to enable one to use capital letters in the adverb to name kchucks whose name is a capital letter.
- At any moment there is only strictly one audio-rate MiniSteno and one control-rate MiniSteno tree active and stored in Library.
- For Audio: Strictly only the chucks contained in the latest compiled MiniSteno tree are audible.  The other chucks are not removed or stopped, but moved to the head of the nullGroup, and their out bus parameter set to 0.  Additionally, at the tail of the nullGroup, create a permanent synth that replaces out (ReplaceOut.kr()), with silence, sent to bus 0, for all channels of Server.default.options.numAudioOutputChannels.  This masks the output of any chucks that are still running but are not contained in the currently active MiniSteno tree. Note: These inactive chucks could also be paused at the moment that they are entered in the nullGroup - but this should be optional, for example for the case of chucks that play audio buffers, when it is desired to keep advancing the playback position.
- In the MiniSteno tree, each chuck has only one input (=in=) and one output (=out=).  However, one can create additional inputs and outputs that access the busses attached to inputs and outputs in other chucks, by using shortcut methods defined in the tiny-sc library that create In and Out ugens, by addressing the source or target chucks per name.  For example:

Read from the default audio output of chuck =x=.
#+BEGIN_SRC sclang
\x.ain  // or just: \x.a
#+END_SRC

Read from the audio output of chuck =x= named =out2=.
#+BEGIN_SRC sclang
\x.ain(\out2) // or just: \z.a(\out2)
#+END_SRC

Read from the default audio output of chuck =x= with an input of 2 channels.
#+BEGIN_SRC sclang
\x.ain(numChans: 2)
#+END_SRC

Read from the default audio output of chuck =x=, with =InFeedback.ar=:
#+BEGIN_SRC sclang
\x.fin // or just \x.af
#+END_SRC

etc.

Read from the default control output of (control rate) chuck =x=.
#+BEGIN_SRC sclang
\x.kin // or just: \x.k
#+END_SRC

etc.

Write to the default audio input of (audio rate) chuck =x=:

#+BEGIN_SRC sclang
\x.out(...)
#+END_SRC

Note that these shortcuts must be attached to the source chucks with notifications so that they change the numbers of their i/o channel when the source chuck's corresponding parameter changes bus index.

- Building the audio-rate mini-steno tree places the chucks in layered groups so that they stay in the correct order.
- While building the mini-steno tree, keep track of which chucks have been added to it.  Use this to:
  - Prevent that a chuck is added twice to the tree.
  - Move chucks that are no longer part of the tree to the nullGroup.
*** MiniSteno extended
:PROPERTIES:
:DATE:     <2015-07-04 Sat 22:58>
:END:
**** DONE Use . as a separator for names of chucks
:PROPERTIES:
:DATE:     <2015-07-04 Sat 23:45>
:END:

#+BEGIN_SRC sclang
  f = { | string |
      string = string.replace (".", "', '");
      string = string
      .replace("(", "', Ser('")
      .replace("[", "', Par('")
      .replace(")", "'), '")
      .replace("]", "'), '")
      .replace(", '')", ")");
      format("Par('%')", string);
  };

  f.("a.b(c[de(f)]x)abra.cadabra");

  //:
  // "a.b.c".replace (".", "', '")
#+END_SRC
**** TODO Modify the MiniSteno tree at any moment
:PROPERTIES:
:DATE:     <2015-07-04 Sat 23:45>
:END:
***** TODO Create named steno branches
:PROPERTIES:
:DATE:     <2015-07-06 Mon 12:05>
:END:

- "stenostring" &> \branchame; :: parses stenostring and puts the resulting subtree at the top level branch of the root tree (Par), replacing any previously existing tree in that position.
- \branchname.remove; :: ...?
- "stenostring" &> \root :: the root branch is the entire active tree.

***** Link two chucks on-the-fly
:PROPERTIES:
:DATE:     <2015-07-06 Mon 12:05>
:END:

- \source &> \effect :: Add \effect serially after \source.  If another chuck \previous is already connected serially to the output of \source, then add \effect in parallel to the existing one: (source.previous) becomes (source[effect.previous])
- \source ^> \effect :: Add \effect serially after \source.  If another chuck \previous is already connected serially to the output of \source, then add \effect between \source and \previous.  (source.previous) becomes (source.effect.previous)


Shortcuts:
***** STARTED Direct creation of link in synth-function code { \sourcechuck.a ... } ++> \fxchuck
:PROPERTIES:
:DATE:     <2015-07-05 Sun 19:55>
:END:

Implementation requires storing the link request in a class var and then executing the link request after compiling the function to a SynthDef but before adding the resulting synthdef to the server via SynthDefLoader.

#+BEGIN_SRC sclang
{ \sourcechuck.a ... } ++> \fxchuck
#+END_SRC

Add \fxchuck serially after \sourcechuck.

: { \sourcechuck.a ... } ++> \fxchuck;

is a shortcut for:

#+BEGIN_SRC sclang
{ Inp.ar ... } ++> \fxchuck;
\sourcechuck &> \fxchuck;
#+END_SRC
***** TODO prevent duplicate chucks in the steno tree
:PROPERTIES:
:DATE:     <2015-07-07 Tue 12:16>
:END:

See notes in: Symbol.asSteno.

***** TODO silence chucks removed from the steno tree
:PROPERTIES:
:DATE:     <2015-07-07 Tue 12:16>
:END:

The following needs to be run for the branch that is modified (branches above or besides this branch are not modified, and therefore do not need to run the following):

1. Get l = list of chucks contained in the branch before the modification.
2. Modify or rebuild (substitute) the branch and store it in var n.
3. For each chuck c in l: If c is not in n, then move c to null-group.  Note: The null group must have a tail synth that silences all outputs.

***** TODO Note: Only the tree being modified needs to be re-rendered for groups and busses
:PROPERTIES:
:DATE:     <2015-07-07 Tue 13:18>
:END:


** STARTED Investigate event sharing/filtering in Chuck (like in Tiny 0)

This is linked to using ().play as play method

Task could be generating the events to be shared. But how to access the shared data?

First steps:

- Passing task as argument to Chuck.play, and having task process Chucks args with its own data.

Next:

Design new class EventFilter that will either be a subclass of Event or contain one, and will respond to method =passArgs=


* Todo
** TODO MiniSteno Par: Use pre-loaded SynthDef for Link synths
:PROPERTIES:
:DATE:     <2015-06-19 Fri 14:24>
:END:
** TODO Test+write examples for Ser(Ser) nesting in MiniSteno
:PROPERTIES:
:DATE:     <2015-06-19 Fri 13:29>
:END:
** TODO Implement stopping (detaching/disabling) of Task Filters
:PROPERTIES:
:DATE:     <2015-06-19 Fri 13:29>
:END:
** TODO Chuck: Enable functions in args for dur filtering etc
:PROPERTIES:
:DATE:     <2015-06-12 Fri 11:58>
:END:


* Done
** DONE Optimize ChuckSynthSource
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-11 Thu 15:58] \\
  Done!
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 12:51>
:END:

Extend ChuckSynthSource with new subclass ChuckFuncSynthSource to add the SynthDef of the Synth source function when a new ChuckFuncSynthSource is created, and create synths with =Synth()= instead of ={ ... }.play=.

This is easy: =Chuck:source({ ... })= (called by: ={ ... } +> \aChuck=) always creates a new ChuckSynthSource instance.

Method ChuckFuncSynthSource:new:

- Construct the name of the SynthDef like this =format("<%>", name)=.
- Immediately construct and =add= the SynthDef, using Function:asSynthDef, possibly with modification of GraphBuilder.wrapOut to add fadeTime as control instead of as one-time-only (fixed) value.
- Use modified Function:play method (possibly named =add=) to /store synth name and notify the containing chuck (!) that it has completed loading/.

Method ChuckFuncSynthSource:prPlay:

Check if synthdef name is set.
- If it is nil, add ChuckFuncSynthSource instance as listener to the containing Chuck instance on message =defloaded= and create the new synth then.
- If it is not nil, play the new synth using the stored synthdef name string.

Note: The ChuckSource class hierarchy becomes:
- ChuckSource
  - Chucksynthsource :: play strings as DefNames with Synth()
    - ChuckFuncSynthSource :: play functions by adding them as SynthDefs and storing the string to play synths as soon as the def is loaded on the server.

** DONE Chuck: Store =out=, =fadeTime= in event, not parent
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

So that they be always included in args when playing ChuckSynthSource with new methods resulting from [[*Optimize%20ChuckSynthSource][Optimize ChuckSynthSource]].

** DONE Debug Tox addition to Tox
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-15 Mon 10:17] \\
  done
- State "DELEGATED"  from "WAITING"    [2015-06-15 Mon 10:17]
:END:
:PROPERTIES:
:ID:       4606C6B7-6175-46CB-B0F7-52434245CFBA
:eval-id:  4
:END:

Possibly the *>> operators add double dependants so re-adding makes the pattern play twice.

** DONE Fix rewiring of source from serial to parallel
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-18 Thu 10:29] \\
  covered by MiniSteno
:END:

#+BEGIN_SRC sclang
//:
Server.default.queryAllNodes;
//: linking

\a +> \b;
{ WhiteNoise.arp } ++> \a;
{ Resonz.arps(In.ar(\in.kr), LFNoise0.kr(30).range(500, 5000)) } ++> \b;
//:


//:
{ Resonz.arps(In.ar(\in.kr), LFNoise2.kr(9).range(150, 500), 5) * 2 } ++> \b;
//:
{ In.ar(\in.kr) * 5 * Decay.kr(Dust.kr(3), 2)} ++> \c;
//: TODO: Fix it so that the following sequence of switches works
\a +> \c;
//:
\b +> \c;
//:
\a +> \b;
//:

\a.toRoot;

\b.toRoot;
#+END_SRC

** DONE Chuck: Rewrite scheduling using a separate class.
:LOGBOOK:
- State "DONE"       from "STARTED"    [2015-06-12 Fri 11:42] \\
  done
- State "STARTED"    from "DONE"       [2015-06-11 Thu 16:00] \\
  still working on removing old scheme, and completing filters
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done - but still working on filters
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

- Should contain a task.
- Can register under same name as Chuck, but in its own subtree.

: ^Registry(ChuckTask, chuckName, { ChuckTask(chuck, pattern) })

Advantages:

- Simplifies Chuck by removing durStream, dur
- Allows sharing of TempoClocks by stopping Task instead of TempoClock.
- Simplifies and standardizes method for generating count + pattern for matching.
- May be used for playing timing structures generated by Org-Mode tables (see PatternLang.org).

** DONE Implement queue of synthdef sends for ().play in ChuckSource
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-19 Fri 12:50] \\
  Done and tested.  Class: SynthDefLoader
:END:
:PROPERTIES:
:DATE:     <2015-06-18 Thu 10:32>
:END:

* Rejected/Cancelled/Obsolete
** OBSOLETE REDO Bus linking using @> and buslinks bound to symbols
:LOGBOOK:
- State "OBSOLETE"   from "!!!"        [2015-06-16 Tue 08:47] \\
  replaced by MiniSteno
:END:

See MiniSteno

For audio busses:

- \bus @>.input \chuck :: Chuck reads from this bus at parameter named by adverb ('input').
- \bus <@.output \chuck :: Chuck writes to this bus at parameter named by adverb ('output').

For control busses

- \bus %>.input \chuck :: Chuck reads from this bus at parameter named by adverb ('input').
- \bus <%.output \chuck :: Chuck writes to this bus at parameter named by adverb ('output').

But you can also use shortcuts:

"source.out>bus.numchans@effect1.in>bus.numchans@effect2".alink; // shortcut: al // = ar

"source.out>bus.numchans@effect1.in>bus.numchans@effect2".klink; // shortcut: kl // = kr
** CANCELED Complete implementation of BusLink unlink method
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2015-06-18 Thu 10:27] \\
  Covered by MiniSteno
:END:
** OBSOLETE Chuck: Store =target= in extra instance var?
:LOGBOOK:
- State "OBSOLETE"   from "TODO"       [2015-06-18 Thu 10:30] \\
  Planning to use ().play as main playing method.  This will require Target to be part of the Event that is played
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:
** OBSOLETE Investigate use of ().play as play method in ChuckSource
:LOGBOOK:
- State "OBSOLETE"   from "CANCELLED"  [2015-06-19 Fri 12:54] \\
  obsolete rather than cancelled - because overtaken by ChuckPatternSource
- State "CANCELLED"  from "TODO"       [2015-06-19 Fri 12:52] \\
  Mushy mushy mushy.  Behavior not so clear as current implementation with synth creation.  Instead, now defining new subclass of ChuckSynthSource, called ChuckPatternSource, which plays EventPatterns.
:END:
** CANCELED ChuckSynthSource+arp, perc: Use release for safer synth stopping
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2015-06-19 Fri 13:06] \\
  Current scheme with SynthDefLoader, dur self-freeing envelopes and release behaves well under all stress-tests so far.
:END:
:PROPERTIES:
:DATE:     <2015-06-12 Fri 11:58>
:END:
