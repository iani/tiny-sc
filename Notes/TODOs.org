* DONE Optimize ChuckSynthSource
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-11 Thu 15:58] \\
  Done!
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 12:51>
:END:

Extend ChuckSynthSource with new subclass ChuckFuncSynthSource to add the SynthDef of the Synth source function when a new ChuckFuncSynthSource is created, and create synths with =Synth()= instead of ={ ... }.play=.

This is easy: =Chuck:source({ ... })= (called by: ={ ... } +> \aChuck=) always creates a new ChuckSynthSource instance.

Method ChuckFuncSynthSource:new:

- Construct the name of the SynthDef like this =format("<%>", name)=.
- Immediately construct and =add= the SynthDef, using Function:asSynthDef, possibly with modification of GraphBuilder.wrapOut to add fadeTime as control instead of as one-time-only (fixed) value.
- Use modified Function:play method (possibly named =add=) to /store synth name and notify the containing chuck (!) that it has completed loading/.

Method ChuckFuncSynthSource:prPlay:

Check if synthdef name is set.
- If it is nil, add ChuckFuncSynthSource instance as listener to the containing Chuck instance on message =defloaded= and create the new synth then.
- If it is not nil, play the new synth using the stored synthdef name string.

Note: The ChuckSource class hierarchy becomes:
- ChuckSource
  - Chucksynthsource :: play strings as DefNames with Synth()
    - ChuckFuncSynthSource :: play functions by adding them as SynthDefs and storing the string to play synths as soon as the def is loaded on the server.

* DONE Chuck: Store =out=, =fadeTime= in event, not parent
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

So that they be always included in args when playing ChuckSynthSource with new methods resulting from [[*Optimize%20ChuckSynthSource][Optimize ChuckSynthSource]].

* TODO Chuck: Store =target= in extra instance var?
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

* STARTED Chuck: Rewrite scheduling using a separate class.
:LOGBOOK:
- State "STARTED"    from "DONE"       [2015-06-11 Thu 16:00] \\
  still working on removing old scheme, and completing filters
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done - but still working on filters
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

- Should contain a task.
- Can register under same name as Chuck, but in its own subtree.

: ^Registry(ChuckTask, chuckName, { ChuckTask(chuck, pattern) })

Advantages:

- Simplifies Chuck by removing durStream, dur
- Allows sharing of TempoClocks by stopping Task instead of TempoClock.
- Simplifies and standardizes method for generating count + pattern for matching.
- May be used for playing timing structures generated by Org-Mode tables (see PatternLang.org).

* Fix rewiring of source from serial to parallel

#+BEGIN_SRC sclang
//:
Server.default.queryAllNodes;
//: linking

\a +> \b;
{ WhiteNoise.arp } ++> \a;
{ Resonz.arps(In.ar(\in.kr), LFNoise0.kr(30).range(500, 5000)) } ++> \b;
//:


//:
{ Resonz.arps(In.ar(\in.kr), LFNoise2.kr(9).range(150, 500), 5) * 2 } ++> \b;
//:
{ In.ar(\in.kr) * 5 * Decay.kr(Dust.kr(3), 2)} ++> \c;
//: TODO: Fix it so that the following sequence of switches works
\a +> \c;
//:
\b +> \c;
//:
\a +> \b;
//:

\a.toRoot;

\b.toRoot;
#+END_SRC
