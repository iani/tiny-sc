* Underway
** TODO Implement queue of synthdef sends for ().play in ChuckSource
:PROPERTIES:
:DATE:     <2015-06-18 Thu 10:32>
:END:



** STARTED MiniSteno

See MiniSteno.sc, MiniSteno class.

Thoughts for further refinement:

- use "astring".asteno for audio config and "astring".ksteno for control config
- Do not use { } @>.param \chuck, because of the problem of naming the created k-chucks.  Stick with ksteno.  Perhaps use: { } @> \kchuck @>.param \achuck or:
  { } @>.param_k \achuck where k is the name of the kchuck.  The name of the chuck is _after_ the name of the parameter to enable one to use capital letters in the adverb to name kchucks whose name is a capital letter.
- At any moment there is only strictly one audio-rate MiniSteno and one control-rate MiniSteno tree active and stored in Library.
- For Audio: Strictly only the chucks contained in the latest compiled MiniSteno tree are audible.  The other chucks are not removed or stopped, but moved to the head of the nullGroup, and their out bus parameter set to 0.  Additionally, at the tail of the nullGroup, create a permanent synth that replaces out (ReplaceOut.kr()), with silence, sent to bus 0, for all channels of Server.default.options.numAudioOutputChannels.  This masks the output of any chucks that are still running but are not contained in the currently active MiniSteno tree. Note: These inactive chucks could also be paused at the moment that they are entered in the nullGroup - but this should be optional, for example for the case of chucks that play audio buffers, when it is desired to keep advancing the playback position.
- In the MiniSteno tree, each chuck has only one input (=in=) and one output (=out=).  However, one can create additional inputs and outputs that access the busses attached to inputs and outputs in other chucks, by using shortcut methods defined in the tiny-sc library that create In and Out ugens, by addressing the source or target chucks per name.  For example:

Read from the default audio output of chuck =x=.
#+BEGIN_SRC sclang
\x.ain
#+END_SRC

Read from the audio output of chuck =x= named =out2=.
#+BEGIN_SRC sclang
\x.ain(\out2)
#+END_SRC

Read from the default audio output of chuck =x= with an input of 2 channels.
#+BEGIN_SRC sclang
\x.ain(numChans: 2)
#+END_SRC

Read from the default audio output of chuck =x=, with =InFeedback.ar=:
#+BEGIN_SRC sclang
\x.fin
#+END_SRC

etc.

Read from the default control output of (control rate) chuck =x=.
#+BEGIN_SRC sclang
\x.kin
#+END_SRC

etc.

Write to the default audio input of (audio rate) chuck =x=:

#+BEGIN_SRC sclang
\x.out(...)
#+END_SRC

Note that these shortcuts must be attached to the source chucks with notifications so that they change the numbers of their i/o channel when the source chuck's corresponding parameter changes bus index.

- Building the audio-rate mini-steno tree places the chucks in layered groups so that they stay in the correct order.
- While building the mini-steno tree, keep track of which chucks have been added to it.  Use this to:
  - Prevent that a chuck is added twice to the tree.
  - Move chucks that are no longer part of the tree to the nullGroup.

** STARTED Investigate event sharing/filtering in Chuck (like in Tiny 0)

This is linked to using ().play as play method

Task could be generating the events to be shared. But how to access the shared data?

First steps:

- Passing task as argument to Chuck.play, and having task process Chucks args with its own data.

Next:

Design new class EventFilter that will either be a subclass of Event or contain one, and will respond to method =passArgs=

** TODO ChuckSynthSource+arp, perc: Use release for safer synth stopping
:PROPERTIES:
:DATE:     <2015-06-12 Fri 11:58>
:END:

** TODO Chuck: Enable functions in args for dur filtering etc
:PROPERTIES:
:DATE:     <2015-06-12 Fri 11:58>
:END:

** TODO Investigate use of ().play as play method in ChuckSource

* Done tasks
** DONE Optimize ChuckSynthSource
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-11 Thu 15:58] \\
  Done!
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 12:51>
:END:

Extend ChuckSynthSource with new subclass ChuckFuncSynthSource to add the SynthDef of the Synth source function when a new ChuckFuncSynthSource is created, and create synths with =Synth()= instead of ={ ... }.play=.

This is easy: =Chuck:source({ ... })= (called by: ={ ... } +> \aChuck=) always creates a new ChuckSynthSource instance.

Method ChuckFuncSynthSource:new:

- Construct the name of the SynthDef like this =format("<%>", name)=.
- Immediately construct and =add= the SynthDef, using Function:asSynthDef, possibly with modification of GraphBuilder.wrapOut to add fadeTime as control instead of as one-time-only (fixed) value.
- Use modified Function:play method (possibly named =add=) to /store synth name and notify the containing chuck (!) that it has completed loading/.

Method ChuckFuncSynthSource:prPlay:

Check if synthdef name is set.
- If it is nil, add ChuckFuncSynthSource instance as listener to the containing Chuck instance on message =defloaded= and create the new synth then.
- If it is not nil, play the new synth using the stored synthdef name string.

Note: The ChuckSource class hierarchy becomes:
- ChuckSource
  - Chucksynthsource :: play strings as DefNames with Synth()
    - ChuckFuncSynthSource :: play functions by adding them as SynthDefs and storing the string to play synths as soon as the def is loaded on the server.

** DONE Chuck: Store =out=, =fadeTime= in event, not parent
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

So that they be always included in args when playing ChuckSynthSource with new methods resulting from [[*Optimize%20ChuckSynthSource][Optimize ChuckSynthSource]].

** DONE Debug Tox addition to Tox
:LOGBOOK:
- State "DONE"       from "DELEGATED"  [2015-06-15 Mon 10:17] \\
  done
- State "DELEGATED"  from "WAITING"    [2015-06-15 Mon 10:17]
:END:
:PROPERTIES:
:ID:       4606C6B7-6175-46CB-B0F7-52434245CFBA
:eval-id:  4
:END:

Possibly the *>> operators add double dependants so re-adding makes the pattern play twice.

** DONE Fix rewiring of source from serial to parallel
:LOGBOOK:
- State "DONE"       from "TODO"       [2015-06-18 Thu 10:29] \\
  covered by MiniSteno
:END:

#+BEGIN_SRC sclang
//:
Server.default.queryAllNodes;
//: linking

\a +> \b;
{ WhiteNoise.arp } ++> \a;
{ Resonz.arps(In.ar(\in.kr), LFNoise0.kr(30).range(500, 5000)) } ++> \b;
//:


//:
{ Resonz.arps(In.ar(\in.kr), LFNoise2.kr(9).range(150, 500), 5) * 2 } ++> \b;
//:
{ In.ar(\in.kr) * 5 * Decay.kr(Dust.kr(3), 2)} ++> \c;
//: TODO: Fix it so that the following sequence of switches works
\a +> \c;
//:
\b +> \c;
//:
\a +> \b;
//:

\a.toRoot;

\b.toRoot;
#+END_SRC

** DONE Chuck: Rewrite scheduling using a separate class.
:LOGBOOK:
- State "DONE"       from "STARTED"    [2015-06-12 Fri 11:42] \\
  done
- State "STARTED"    from "DONE"       [2015-06-11 Thu 16:00] \\
  still working on removing old scheme, and completing filters
- State "DONE"       from "TODO"       [2015-06-11 Thu 15:59] \\
  done - but still working on filters
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:

- Should contain a task.
- Can register under same name as Chuck, but in its own subtree.

: ^Registry(ChuckTask, chuckName, { ChuckTask(chuck, pattern) })

Advantages:

- Simplifies Chuck by removing durStream, dur
- Allows sharing of TempoClocks by stopping Task instead of TempoClock.
- Simplifies and standardizes method for generating count + pattern for matching.
- May be used for playing timing structures generated by Org-Mode tables (see PatternLang.org).

* Rejected/Cancelled/Obsolete
** OBSOLETE REDO Bus linking using @> and buslinks bound to symbols
:LOGBOOK:
- State "OBSOLETE"   from "!!!"        [2015-06-16 Tue 08:47] \\
  replaced by MiniSteno
:END:

See MiniSteno

For audio busses:

- \bus @>.input \chuck :: Chuck reads from this bus at parameter named by adverb ('input').
- \bus <@.output \chuck :: Chuck writes to this bus at parameter named by adverb ('output').

For control busses

- \bus %>.input \chuck :: Chuck reads from this bus at parameter named by adverb ('input').
- \bus <%.output \chuck :: Chuck writes to this bus at parameter named by adverb ('output').

But you can also use shortcuts:

"source.out>bus.numchans@effect1.in>bus.numchans@effect2".alink; // shortcut: al // = ar

"source.out>bus.numchans@effect1.in>bus.numchans@effect2".klink; // shortcut: kl // = kr
** CANCELLED Complete implementation of BusLink unlink method
:LOGBOOK:
- State "CANCELLED"  from "TODO"       [2015-06-18 Thu 10:27] \\
  Covered by MiniSteno
:END:
** OBSOLETE Chuck: Store =target= in extra instance var?
:LOGBOOK:
- State "OBSOLETE"   from "TODO"       [2015-06-18 Thu 10:30] \\
  Planning to use ().play as main playing method.  This will require Target to be part of the Event that is played
:END:
:PROPERTIES:
:DATE:     <2015-06-09 Tue 14:04>
:END:
