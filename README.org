#+TITLE: Tiny-sc / Branch: retiny

/Compact coding tools for SuperCollider, with Emacs Org-mode intergration/

This is version 1.0alpha (=retiny=).

* Installation

- Download the library from http://github.com/iani/tiny-sc.
- Place the tiny-sc folder in the SuperCollider Extensions folder (found by executing this in SuperCollider):
  : Platform.userExtensionDir;
- Recompile the library (Command-Shift-L or menu Lang Recompile in the IDE).

* Principles

Tiny-sc uses class =Chuck= to define containers that can run synths. It also defines some shortcuts for commonly used UGen combinations and patterns and for control UGen arugments such as amp, Pan and various envelopes.  A Chuck can be driven by a TaskPlayer to run patterns in a similar way as Pbind.  The difference is that any key of a pattern as well as the duration pattern can be changed at any time.  Furthermore, a Chuck can switch TaskPlayers at any time, and can also be made to respond to a TaskFilter which only plays at beats that match a given condition.  In this way, several Chuck instances can be synchronized by following the same TaskPlayer or its attached filters.  Finally, the audio output of a Chuck can be linked to the input of another Chuck.  Many-to-one and one-to-many audio link configurations are possible.  The library deals with bus allocation and synth order management in the background, by responding to a linking request (using operator  '=>').

* Tutorial

** Playing functions
:PROPERTIES:
:ID:       BBAE67F1-8F91-4D01-B5D9-F53E9DB05053
:eval-id:  11
:END:

Start playing a function:

#+BEGIN_SRC sclang
{ SinOsc.arps(400) } ==> \mysound;
#+END_SRC

Replace it with another function:

#+BEGIN_SRC sclang
{ PinkNoise.arps.perc(0.5) } ==> \mysound;
#+END_SRC

Replay the previously stored function:

#+BEGIN_SRC sclang
\mysound.play;
#+END_SRC


** Playing synthdefs
:PROPERTIES:
:ID:       C85BF4A1-62C2-4177-9BBC-238C999C5C19
:eval-id:  3
:END:

#+BEGIN_SRC sclang
"default" ==> \mysound;
#+END_SRC

** Set play source without actually playing
:PROPERTIES:
:ID:       8098716E-FA7F-434D-96B8-72265944E415
:eval-id:  10
:END:

Replace the play function without playing the synth:

#+BEGIN_SRC sclang
{ SinOsc.arps(Rand(400, 800)) } => \mysound;
#+END_SRC
Trigger manually at any point:

#+BEGIN_SRC
\mysound.play;
#+END_SRC

** Releasing
:PROPERTIES:
:ID:       3A6A7AE9-41E9-483B-80E4-0E441D8249CA
:eval-id:  2
:END:

Release with default time:

#+BEGIN_SRC sclang
\mysound.release;
#+END_SRC

Release with custom time:

(First, start the sound again:)

: \mysound.play;

Now release:

: \mysound release: 5;

** Setting fade time (for cross fade)
:PROPERTIES:
:ID:       7EF85C8E-3E7C-4775-94FD-36AD8EBD29C5
:eval-id:  24
:END:

: \mysound.fadeTime = 1;

Try several different sounds with cross fade, one after the other:

#+BEGIN_SRC sclang
{ Blip.arps(Line.kr(Rand(400, 500), Rand(500, 800), 0.2), 3) } ==> \mysound;
#+END_SRC

#+BEGIN_SRC sclang
{ WhiteNoise.arps } ==> \mysound;
#+END_SRC

#+BEGIN_SRC sclang
{ PinkNoise.arps } ==> \mysound;
#+END_SRC

** Setting function/synth arguments (parameters)

Set a parameter to use in the synth's arguments:

600 =>.freq \mysound;

Test it:

{ SinOsc.arps(\freq.kr(400)) } => \mysound;

Setting a new parameter value immediately sends it to the synth:

: 800 =>.freq \mysound;

** UGen shortcuts

(Incomplete)

*** sine

Multiply UGen or UGen array output with =EnvGen.kr(Env.sine(\dur.kr(dur), level))=.  This provides a sine-shaped envelope, whose duration is controlled by the value of =dur= in arguments.

Set the function to play.
: { SinOsc.arps(Rand(400, 800)).sine } ==> \envtest;

Test using default duration value:
: \envtest.play;

Observe changing duration of envelope according to value of =dur= from timing pattern:

: [0.05, 0.1, 0.5, 1].collect(_.pn(8)).pseq |> \envtest;

Alternatively:

: [1, 0.1, 0.5, 2, 0.1.pn(4)].prand |> \envtest;

*** perc

Like =sine= but with =Env.perc=.

*** arp

Create control name =amp= with default value 0.1 and multiply it with the receiver UGen or UGen array.

*** arps

Like arp, but send the output to an array of 2 channels.  Can be used to quickly convert a UGen functions output to stereo ouput + provide amplitude control.

***

** Linking output to input of other Chucks

Create a Chuck to be the source:

: { PinkNoise.arp() } => \source;

Create an effect to play the source with:

: { Resonz.ar(In.ar(\in.ar(0)), LFNoise0.ar(30).range(300, 8000), 3) } => \effect1;

Send source to effect:

: \source => \effect1;

Second effect:

: { In.ar(\in.ar(0)) * Decay2.kr(Dust.kr(3.dup, 3), 0.5, 2) } => \effect2;

Send first effect to second effect, creating chain =source -> effect1 -> effect2=

: \effect1 => \effect2;

Unlink output and send to root channel output (Channel 0):

Example 1: Send effect1 directly to output, bypassing effect2:

: \effect1.toRoot;

Example 2: Send source directly to output, bypassing effect1:

: \source.toRoot;

** Playing patterns

*** Playing patterns in parameters

Set a function to play the pattern with

{ SinOsc.arps(\freq.kr(400)) } => \patsound;

Obtain successive values of parameter =freq= from a pattern:

[60, 65, 67].midicps.pseq =>.freq \patsound;

Try playing =patsound= repeatedly, to hear the sequence of values:

\patsound.play; // run this several times in sequence

*** Timing sequences of play events in a Chuck

Play =patsound= repeatetedly at duration intervals of 0.1 seconds:

: 0.1 |> \patsound;

Use a pattern as source of successive durations between events:

: [0.2, 0.1].pseq |> \patsound;
*** Triggering multiple instances from one pattern

: \sub |>.xoxoxoxx \master;

: { WhiteNoise.arps() } ==> \sub;

: 0.1 |> \master;


: \sub2 |>.oxoxxxoo \master;

: { BrownNoise.arps() } ==> \sub2;



: \sub3 |>.xoxxx___ \master;

: { LFPulse.arps(\freq.kr(800)) } ==> \sub3;

: [60, 64, 67, 69].midicps.pseq =>.freq \sub3;


: \sub3 |>.x_xxxooo \sub2;

: \sub4 |>.xo \sub3;

: { SinOsc.arp([2500, 2000]).perc(0.3) * 2 } ==> \sub4;


: 0.1 |> \m1;

: \r1 |>.xox \m1;

: { WhiteNoise.arps().perc } ==> \r1;

: \r2 |>.xox \m1;

: [60, 62].midicps.pseq =>.freq \r2

: { SinOsc.arps(\freq.kr(400)) } ==> \r2;

: \r2 |>.xox \r1;

: [64, 65].midicps.pseq =>.freq \r3

: { SinOsc.arp(\freq.kr(400) * [1, 1.2]) } ==> \r3;

: \r3 |>.xox \m1;

: \r3 |>.xox \r1;

: \r3 |>.xox \r2;

: \r3 |>.x_x \r2;

: (40..80).midicps.prand =>.freq \r3;

*** Multiple voice example
:PROPERTIES:
:ID:       E5056ED9-4D0C-4BB4-A5B9-26429CD7FA11
:eval-id:  14
:END:

#+BEGIN_SRC sclang
  (
  { | n |
      var name;
      name = format("multi%", n).asSymbol;
      n = n % 4;
      {
          Blip.arps(
              1 + n / 2 * Line.kr(Rand(20, 80).midicps, Rand(20, 80).midicps, Rand(0.1, 1)),
              Line.kr(Rand(5, 25), Rand(5, 25), 0.5)
          ).perform([\perc, \sine]@@n)
      } ==> name;

      ([0.25.pn(14), 5 ! 3, 1, 2, 0.1 ! 10, 3] / (0.5 + (n / 4))).flat.prand *> name;
  } ! 8;
  )
#+END_SRC
