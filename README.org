#+TITLE: Tiny-sc / Branch: retiny

/Compact coding tools for SuperCollider, with Emacs Org-mode intergration/

This is version 1.0alpha (=retiny=).

* Installation

- Download the library from http://github.com/iani/tiny-sc.
- Place the tiny-sc folder in the SuperCollider Extensions folder (found by executing this in SuperCollider):
  : Platform.userExtensionDir;
- Recompile the library (Command-Shift-L or menu Lang Recompile in the IDE).

* Principles

Tiny-sc uses class =Chuck= to define containers that can run synths or patterns. It also defines some shortcuts for commonly used UGen combinations and patterns and for control UGen arugments such as amp, Pan and various envelopes.

* Tutorial

** Playing functions

Start playing a function:

: { SinOsc.arps(400) } => \mysound;

Replace it with another function:

: { PinkNoise.arps.perc(0.5) } => \mysound;

Replay the previously stored function:

: \mysound.play;

** Playing synthdefs

: "default" => \mysound;

** Set play source without actually playing

Replace the play function without playing the synth:

: { SinOsc.arps(Rand(400, 800)) } ==> \mysound;

Trigger manually at any point:

: \mysound.play;

** Releasing

Release with default time:

: \mysound.release;

Release with custom time:

(First, start the sound again:)

: \mysound.play;

Now release:

: \mysound release: 5;

** Setting fade time (for cross fade)

: \mysound.fadeTime = 1;

Try several different sounds with cross fade, one after the other:

: { LFSaw.arps(Rand(400, 800)) } => \mysound;
: { WhiteNoise.arps } => \mysound;
: { PinkNoise.arps } => \mysound;

** Setting function/synth arguments (parameters)

Set a parameter to use in the synth's arguments:

: 600 =>.freq \mysound;

Test it:

: { SinOsc.arps(\freq.kr(400)) } => \mysound;

Setting a new parameter value immediately sends it to the synth:

: 800 =>.freq \mysound;

** UGen shortcuts

(Incomplete)

*** sine

Multiply UGen or UGen array output with =EnvGen.kr(Env.sine(\dur.kr(dur), level))=.  This provides a sine-shaped envelope, whose duration is controlled by the value of =dur= in arguments.

Set the function to play.
: { SinOsc.arps(Rand(400, 800)).sine } ==> \envtest;

Test using default duration value:
: \envtest.play;

Observe changing duration of envelope according to value of =dur= from timing pattern:

: [0.05, 0.1, 0.5, 1].collect(_.pn(8)).pseq |> \envtest;

Alternatively:

: [1, 0.1, 0.5, 2, 0.1.pn(4)].prand |> \envtest;

*** perc

Like =sine= but with =Env.perc=.

*** arp

Create control name =amp= with default value 0.1 and multiply it with the receiver UGen or UGen array.

*** arps

Like arp, but send the output to an array of 2 channels.  Can be used to quickly convert a UGen functions output to stereo ouput + provide amplitude control.

***

** Linking output to input of other Chucks

Create a Chuck to be the source:

: { PinkNoise.arp() } => \source;

Create an effect to play the source with:

: { Resonz.ar(In.ar(\in.ar(0)), LFNoise0.ar(30).range(300, 8000), 3) } => \effect1;

Send source to effect:

: \source => \effect1;

Second effect:

: { In.ar(\in.ar(0)) * Decay2.kr(Dust.kr(3.dup, 3), 0.5, 2) } => \effect2;

Send first effect to second effect, creating chain =source -> effect1 -> effect2=

: \effect1 => \effect2;

Unlink output and send to root channel output (Channel 0):

Example 1: Send effect1 directly to output, bypassing effect2:

: \effect1.toRoot;

Example 2: Send source directly to output, bypassing effect1:

: \source.toRoot;

** Playing patterns

*** Playing patterns in parameters

Set a function to play the pattern with

: { SinOsc.arps(\freq.kr(400)) } ==> \patsound;

Obtain successive values of parameter =freq= from a pattern:

: [60, 65, 67].midicps.pseq =>.freq \patsound;

Try playing =patsound= repeatedly, to hear the sequence of values:

: \patsound.play;

*** Timing sequences of play events in a Chuck

Play =patsound= repeatetedly at duration intervals of 0.1 seconds:

: 0.1 |> \patsound;

Use a pattern as source of successive durations between events:

: [0.2, 0.1].pseq |> \patsound;
*** Triggering multiple instances from one pattern

: \sub |>.xoxoxoxx \master;

: { WhiteNoise.arps() } ==> \sub;

: 0.1 |> \master;


: \sub2 |>.oxoxxxoo \master;

: { BrownNoise.arps() } ==> \sub2;



: \sub3 |>.xoxxx___ \master;

: { LFPulse.arps(\freq.kr(800)) } ==> \sub3;

: [60, 64, 67, 69].midicps.pseq =>.freq \sub3;


: \sub3 |>.x_xxxooo \sub2;

: \sub4 |>.xo \sub3;

: { SinOsc.arp([2500, 2000]).perc(0.3) * 2 } ==> \sub4;


: 0.1 |> \m1;

: \r1 |>.xox \m1;

: { WhiteNoise.arps().perc } ==> \r1;

: \r2 |>.xox \m1;

: [60, 62].midicps.pseq =>.freq \r2

: { SinOsc.arps(\freq.kr(400)) } ==> \r2;

: \r2 |>.xox \r1;

: [64, 65].midicps.pseq =>.freq \r3

: { SinOsc.arp(\freq.kr(400) * [1, 1.2]) } ==> \r3;

: \r3 |>.xox \m1;

: \r3 |>.xox \r1;

: \r3 |>.xox \r2;

: \r3 |>.x_x \r2;

: (40..80).midicps.prand =>.freq \r3;

*** Multiple voice example
:PROPERTIES:
:ID:       E5056ED9-4D0C-4BB4-A5B9-26429CD7FA11
:eval-id:  5
:END:

#+BEGIN_SRC sclang
(
{ | n |
	var name, voiceFactor;
	name = format("multi%", n).asSymbol;
	voiceFactor = 1 + n / 2;
	{ Blip.arps(voiceFactor * Line.kr(Rand(100, 500), voiceFactor * Rand(100, 500),
		Rand(0.1, 1)), Line.kr(Rand(5, 25), Rand(5, 25), 0.5)).perform([\perc, \sine]@@n)
	} ==> name;

([0.25.pn(14), 1, 2, 0.1 ! 10, 3] / (0.5 + (n / 4))).flat.prand *> name;
} ! 4;
)
#+END_SRC
