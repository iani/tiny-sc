#+TITLE: Tiny-sc / Branch: retiny

/Compact coding tools for SuperCollider, with Emacs Org-mode intergration/

*Canis plenus et libum totum*

*(Libum mandere et habere)*

This is version 1.1alpha (=retiny=).

* Installation

- Download the library from http://github.com/iani/tiny-sc.
- Place the tiny-sc folder in the SuperCollider Extensions folder (found by executing this in SuperCollider):
  : Platform.userExtensionDir;
- Recompile the library (Command-Shift-L or menu Lang Recompile in the IDE).

* Introduction
:PROPERTIES:
:ID:       C9CDEADF-7149-4422-B02C-8D7A1F0C940C
:eval-id:  121
:END:

** Synth Processes and their parameters
:PROPERTIES:
:ID:       5A4BBD0F-7722-42C9-8E7D-50E3AACCAF34
:eval-id:  51
:END:
Tiny-sc uses class =Chuck= to define containers that can run synths. It also defines some shortcuts for commonly used UGen combinations and patterns and for control UGen arugments such as amp, Pan and various envelopes.  Chuck instances are accessed by their name.  Playing a SynthDef function or a SynthDef name will start a new Synth and fade out the previous one:

#+BEGIN_SRC sclang
{ WhiteNoise.ar(0.1) } ++> \test; // ++> starts immediately
#+END_SRC

Play different synthdef, replace previous synth:

#+BEGIN_SRC sclang
"default" ++> \test; // play with SynthDef "default"
#+END_SRC

Parameters of a Chuck's synth process can be set as numbers:

#+BEGIN_SRC sclang
1000 +>.freq \test;
#+END_SRC

Or as patterns:

#+BEGIN_SRC sclang
Pwhite(100, 200, inf) +>.freq \test;
#+END_SRC

Play again, using the next values from argument patterns:

#+BEGIN_SRC sclang
\test.play;
#+END_SRC

Release with custom fade-out duration:

#+BEGIN_SRC sclang
\test.release(3);
#+END_SRC

** Playing sequences of synth events
:PROPERTIES:
:ID:       C169857C-C151-4D9B-8BC3-A588AD4FFE59
:eval-id:  47
:END:
A Chuck can play with a duration pattern, which may be a single number:

#+BEGIN_SRC sclang
\test *> 0.1;
#+END_SRC

or a pattern:

#+BEGIN_SRC sclang
\test *> Prand([Pn(0.05, 4), 0.3], inf);
#+END_SRC

Stop the pattern that drives the Chuck:

#+BEGIN_SRC sclang
\test.stop;
#+END_SRC

** Task Player filters
:PROPERTIES:
:ID:       33EC0959-E840-4DA0-9891-0692387E5332
:eval-id:  331
:END:

Feature is still experimental.

A Chuck can be driven by a TaskPlayer to run patterns in a similar way as Pbind.  The difference is that any key of a pattern as well as the duration pattern can be changed at any time.  Furthermore, a Chuck can switch TaskPlayers at any time, and can also be made to respond to a TaskFilter which only plays at beats that match a given condition.  In this way, several Chuck instances can be synchronized by following the same TaskPlayer or its attached filters.

Start the test Chuck with a new SynthDef function, and a pattern:
#+BEGIN_SRC sclang
{ Blip.arps(\freq.kr(400), 3) } +> \test2 *> 0.1;
(60..90).midicps.prand +>.freq \test2;
#+END_SRC

Add a second chuck to the same pattern:

(Note: =+>= waits to be triggered, and =**>= does not restart the task)

#+BEGIN_SRC sclang
{ SinOsc.arps(Rand(2000, 3000)).perc } +> \twock **> \test2;
#+END_SRC

Currently there is only one kind of filter, which is created by adding an adverb with its pattern to the =*>= operator.  The adverb may consist of characters =x=, =o= and =_=.  Their meanings are:

- x :: play new note for this beat.
- o :: stop note, remain silent.
- _ :: hold previous note (do not release).

Example:

#+BEGIN_SRC sclang
\test2 **>.xooox___x_xo \test2; // **> : Do not start parent task
#+END_SRC

Remove chuck named =test= from its task - but leave the other Chucks still attached:

#+BEGIN_SRC sclang
\test2.removeTask;
#+END_SRC

Stop the task, and all it's dependent Chucks:

#+BEGIN_SRC sclang
\test2.stop;
#+END_SRC

Here is a more complex example:

#+BEGIN_SRC sclang
"default" +> \high; // set source of chuck high
Pwhite(70, 90, inf).midicps +>.freq \high; // set frequency pattern for high
{ Blip.arps(Rand(100, 300), 3).perc } +> \low; // set source of chuck low
\high **> \low; // Make high follow task pattern of low
\low *> 0.1;   // Set and start task pattern of low to play beats at 0.1 seconds
#+END_SRC

Let =high= play a sub-pattern of the TaskPlayer =low=.

#+BEGIN_SRC sclang
\high **>.xooox___x_xoxoxx \low; // creates filter \_low and attaches chuck \high to it
#+END_SRC

Change the duration pattern of master Task =low=:

#+BEGIN_SRC sclang
\low **> Prand([Pn(0.08, 4), 0.3], inf);
#+END_SRC

Make both =high= and =low= play on the same filter of =low= Task;
#+BEGIN_SRC sclang
\high **>.xooox___xx_x_xxxx \low; // create filter \_low and attaches chuck \low to it
\low **> \_low; // also make chuck low follow filter \_low
#+END_SRC

Change base beat pattern and reset =low= to that root pattern:
#+BEGIN_SRC sclang
\low **> 0.2;
#+END_SRC

Change base beat pattern again:
#+BEGIN_SRC sclang
\low **> Prand([Pn(0.12, 4), 0.3, 0.6, Pn(0.06, 2)], inf);
#+END_SRC

Synch chuck =low= with chuck =high= again:
#+BEGIN_SRC sclang
\low **> \_low; // also make chuck low follow filter \_low
#+END_SRC

Stop the master pattern:

#+BEGIN_SRC sclang
\low.stop;
#+END_SRC
** Linking audio inputs and outputs between synths
:PROPERTIES:
:ID:       EA903FD5-9FE9-4B0A-BEE0-B38C8807810E
:eval-id:  88
:END:
The audio output of a Chuck can be linked to the input of another Chuck.  Many-to-one and one-to-many audio link configurations are possible.  The library deals with bus allocation and synth order management in the background, by responding to a linking request (using operator  '+>').

Start a source and an effect:
#+BEGIN_SRC sclang
{ PinkNoise.ar(0.1) } ++> \source;  // this will be heard without effect - not linked yet!
{ Resonz.arp(In.ar(\in.kr(0)) * 500, LFNoise0.kr(30).range(400, 2000), 0.001) } ++> \effect;
#+END_SRC

Link the source to the effect:
#+BEGIN_SRC sclang
\source +> \effect;
#+END_SRC

Unlink the source from the effect, and send it back to default output:

#+BEGIN_SRC sclang
\source.toRoot;
#+END_SRC

Add a second effect:

#+BEGIN_SRC sclang
{ In.ar(\in.kr) * 3 * Decay2.kr(Dust.kr([1, 1]), 0.01, 1.0) } ++> \effect2;
#+END_SRC

Create audio link chain: source -> effect -> effect;

#+BEGIN_SRC slcang
\source +> \effect;
\effect +> \effect2;
#+END_SRC

Make the first effect send directly to output again, bypassing the second effect:
#+BEGIN_SRC sclang
\effect.toRoot;
#+END_SRC

Make source send to both effect and effect2
#+BEGIN_SRC sclang
\source +> \effect2;
#+END_SRC

Keep source sending to effect and effect2, and make effect send to effect2:
#+BEGIN_SRC sclang
\effect +> \effect2;
#+END_SRC

Stop source and effects:
#+BEGIN_SRC sclang
\source.release;
\effect.release;
\effect2.release;
#+END_SRC

** Multiple voice example
:PROPERTIES:
:ID:       CDEFFE5C-E976-4D0C-9983-A5E27467AB0F
:eval-id:  181
:END:

Just a demo with 8 Chuck instances playing on 8 different TaskPlayers.

#+BEGIN_SRC sclang
  (
  { | n |
      var name;
      name = format("multi%", n).asSymbol;
      n = n % 4;
      {
          Blip.arps(
              1 + n / 2 * Line.kr(Rand(20, 80).midicps, Rand(20, 80).midicps, Rand(0.1, 1)),
              Line.kr(Rand(5, 25), Rand(5, 25), 0.5)
          ).perform([\perc, \sine]@@n)
      } +> name;

      ([0.25.pn(14), 5 ! 3, 1, 2, 0.1 ! 10, 3] / (0.5 + (n / 4))).flat.prand *> name;
  } ! 8;
  )
#+END_SRC

Use task filters to change density of the texture:

#+BEGIN_SRC sclang
\multi0 **>.xoooo \multi0; // use **> to prevent re-starting the master Task
\multi1 **>.xoooo \multi1;
\multi2 **>.xoooo \multi2;
\multi3 **>.x \multi3;
\multi4 **>.xoooo \multi4;
\multi5 **>.xoooo \multi5;
\multi6 **>.xoooo \multi6;
\multi7 **>.xoooo \multi7;
#+END_SRC

Variation 1:

#+BEGIN_SRC sclang
\multi0 **>.xoooo \multi0;
\multi1 **>.o \multi1;
\multi2 **>.o \multi2;
\multi3 **>.x \multi3;
\multi4 **>.o \multi4;
\multi5 **>.o \multi5;
\multi6 **>.o \multi6;
\multi7 **>.xo \multi7;
#+END_SRC

Variation 2:

#+BEGIN_SRC sclang
\multi7 **> \multi7;
\multi6 **>.xo \multi7;
\multi5 **>>.xo \_multi7;
\multi4 **>>.xo \__multi7;
\multi3 **>>.xo \___multi7;
\multi2 **>>.xo \____multi7;
\multi1 **>>.xo \_____multi7;
\multi0 **>>.xo \______multi7;
#+END_SRC

Variation 3:

#+BEGIN_SRC sclang
\multi7 *> 0.1;
#+END_SRC

Variation 4:

#+BEGIN_SRC sclang
([0.25.pn(14), 5 ! 3, 1, 0.4 ! 10, 0.1 ! 20, 3] / 4).flat.prand *> \multi7;
{ | n | Pfunc({ 0.01 exprand: 0.35 }) +>.amp format("multi%", n).asSymbol } ! 8;
#+END_SRC

Variation 5:

#+BEGIN_SRC sclang
([0.25.pn(14), 5 ! 3, 1, 0.4 ! 10, 0.1 ! 20, 3] / 4).flat.prand *> \multi7;
\multi7 **> \multi7;
\multi6 **>.xo \multi7;
\multi5 **>>.xo \_multi7;
\multi4 **>>.xo \__multi7;
([0.25.pn(14), 5 ! 3, 1, 0.4 ! 10, 0.1 ! 20, 3]).flat.prand *> \multi3;
\multi3 **>.xoo \multi3;
\multi2 **>>.xoo \_multi3;
\multi1 **>>.xoo \__multi3;
\multi0 **>>.xoo \___multi3;
#+END_SRC

To end the sound, stop all tasks:
#+BEGIN_SRC sclang
TaskPlayer.stopAll;
#+END_SRC

Now gradually build some background texture and rhythms with the same synth sources:
#+BEGIN_SRC sclang
0.01 *> \multi0;
#+END_SRC

#+BEGIN_SRC sclang
0.1 *> \multi1;
#+END_SRC

#+BEGIN_SRC sclang
\multi2 **>>.xo \multi1;
0.5 +>.amp \multi2;
#+END_SRC

#+BEGIN_SRC sclang
\multi3 **>>.xo \_multi1;
#+END_SRC
