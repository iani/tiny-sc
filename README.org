#+TITLE: Tiny-sc / Branch: retiny

/Compact coding tools for SuperCollider, with Emacs Org-mode intergration/

This is version 1.0alpha (=retiny=).

* Installation

- Download the library from http://github.com/iani/tiny-sc.
- Place the tiny-sc folder in the SuperCollider Extensions folder (found by executing this in SuperCollider):
  : Platform.userExtensionDir;
- Recompile the library (Command-Shift-L or menu Lang Recompile in the IDE).

* Introduction
:PROPERTIES:
:ID:       C9CDEADF-7149-4422-B02C-8D7A1F0C940C
:eval-id:  121
:END:

Tiny-sc uses class =Chuck= to define containers that can run synths. It also defines some shortcuts for commonly used UGen combinations and patterns and for control UGen arugments such as amp, Pan and various envelopes.  Chuck instances are accessed by their name.  Playing a SynthDef function or a SynthDef name will start a new Synth and fade out the previous one:

#+BEGIN_SRC sclang
{ WhiteNoise.ar(0.1) } ==> \test; // ==> starts immediately
#+END_SRC

Play different synthdef, replace previous synth:

#+BEGIN_SRC sclang
"default" ==> \test;
#+END_SRC

Parameters of a Chuck's synth process can be set as numbers:

#+BEGIN_SRC sclang
1000 =>.freq \test;
#+END_SRC

Or as patterns:

#+BEGIN_SRC sclang
Pwhite(100, 200, inf) =>.freq \test;
#+END_SRC

A Chuck can play with a duration pattern, which may be a single number:

#+BEGIN_SRC sclang
\test *> 0.1;
#+END_SRC

or a pattern:

#+BEGIN_SRC sclang
\test *> Prand([Pn(0.05, 4), 0.3], inf);
#+END_SRC

Stop the pattern that drives the Chuck:

#+BEGIN_SRC sclang
\test.stop;
#+END_SRC

A Chuck can be driven by a TaskPlayer to run patterns in a similar way as Pbind.  The difference is that any key of a pattern as well as the duration pattern can be changed at any time.  Furthermore, a Chuck can switch TaskPlayers at any time, and can also be made to respond to a TaskFilter which only plays at beats that match a given condition.  In this way, several Chuck instances can be synchronized by following the same TaskPlayer or its attached filters.

#+BEGIN_SRC sclang
{ SinOsc.arps(Rand(2000, 3000)).perc } => \twock; // => waits to be triggered
\twock *> \test; // Also restarts the task player.
#+END_SRC

Remove chuck named =test= from its task - but leave the other Chucks still attached:

#+BEGIN_SRC sclang
\test.removeTask;
#+END_SRC

Stop the task, and all it's dependent Chucks:

#+BEGIN_SRC sclang
\test.stop;
#+END_SRC

Finally, the audio output of a Chuck can be linked to the input of another Chuck.  Many-to-one and one-to-many audio link configurations are possible.  The library deals with bus allocation and synth order management in the background, by responding to a linking request (using operator  '=>').

Start a source and an effect:
#+BEGIN_SRC sclang
{ PinkNoise.ar(0.1) } ==> \source;
{ Resonz.arps(In.ar(\in.kr(0)) * 100, LFNoise0.kr(30).range(400, 2000), 0.001) } ==> \effect;
#+END_SRC

Link the source to the effect:
#+BEGIN_SRC sclang
\source => \effect;
#+END_SRC

Unlink the source from the effect, and send it back to default output:

#+BEGIN_SRC sclang
\source.toRoot;
#+END_SRC

Stop both source and effect:
#+BEGIN_SRC sclang
\source.release;
\effect.release;
#+END_SRC

Multiple voice example:
#+BEGIN_SRC sclang
  (
  { | n |
      var name;
      name = format("multi%", n).asSymbol;
      n = n % 4;
      {
          Blip.arps(
              1 + n / 2 * Line.kr(Rand(20, 80).midicps, Rand(20, 80).midicps, Rand(0.1, 1)),
              Line.kr(Rand(5, 25), Rand(5, 25), 0.5)
          ).perform([\perc, \sine]@@n)
      } ==> name;

      ([0.25.pn(14), 5 ! 3, 1, 2, 0.1 ! 10, 3] / (0.5 + (n / 4))).flat.prand *> name;
  } ! 8;
  )
#+END_SRC

To end the sound, stop all tasks:
#+BEGIN_SRC sclang
TaskPlayer.stopAll;
#+END_SRC
